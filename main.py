import requests
import json
import logging
from datetime import datetime, timedelta # Ch·∫Øc ch·∫Øn c√≥ 'time' ·ªü ƒë√¢y
import threading
import time # Gi·ªØ l·∫°i n·∫øu b·∫°n d√πng time.sleep() ho·∫∑c c√°c h√†m kh√°c t·ª´ module 'time'
import os
import time
import logging
import requests
import re
import base64
import uuid
import json
from datetime import datetime, timezone
from io import BytesIO
from PIL import Image
import random
import string
import threading
from telebot import types
from flask import Flask, request
from threading import Thread
import telebot
from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
from types import SimpleNamespace

# --- C·∫•u h√¨nh logging ---
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("bot.log"),
        logging.StreamHandler()
    ]
)

# --- C·∫•u h√¨nh chung ---
TOKEN = os.environ.get("BOT_TOKEN", "7539540916:AAENFBF2B2dyXLITmEC2ccgLYim2t9vxOQk")
ADMIN_ID = int(os.environ.get("ADMIN_ID", 5819094246))
APP_URL = os.environ.get("APP_URL", "https://zproject-111.onrender.com")
AUTO_LIKE_CHANNEL_ID = -1002625481749 # ID nh√≥m ƒë·ªÉ g·ª≠i th√¥ng b√°o auto like
SAVE_ID_API_URL = "http://zproject-api-sever-tele.x10.mx/api-save-id.php"
SAVE_ID_JSON_URL = "http://zproject-api-sever-tele.x10.mx/save-id-auto.json"
RENT_AUTO_LIKE_BUTTON_URL = "https://t.me/zproject2"
AUTO_LIKE_IMAGE_URL = "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTX1YPg46wifavrl54ymwR5a6m5d4dgJnkRsg&s"

# L∆∞u tr·ªØ c√°c UID c·∫ßn auto like
# THAY ƒê·ªîI M·ªöI: ID c·ªßa nh√≥m b·∫Øt bu·ªôc
REQUIRED_GROUP_ID = -1002538618385  # Thay b·∫±ng ID nh√≥m Telegram c·ªßa b·∫°n: https://t.me/zproject3
REQUIRED_GROUP_LINK = "https://t.me/zproject3" # Link m·ªùi tham gia nh√≥m

logging.info(f"APP_URL ƒë∆∞·ª£c c·∫•u h√¨nh: {APP_URL}")

bot = telebot.TeleBot(TOKEN, threaded=True)
app = Flask(__name__)
START_TIME = time.time()

# Bi·∫øn to√†n c·ª•c v√† c√°c Lock ƒë·ªÉ b·∫£o v·ªá truy c·∫≠p ƒëa lu·ªìng
USER_IDS = set()
GROUP_INFOS = []
user_data = {}
bot.feedback_messages = {}
bot.code_snippets = {}
bot.voice_map = {}
bot.mail_messages_state = {}
bot.noti_states = {}
interaction_count = 730
auto_like_uids = []
last_auto_like_date = {} # L∆∞u ng√†y cu·ªëi c√πng auto like cho m·ªói UID

# Kh·ªüi t·∫°o Locks cho c√°c bi·∫øn d√πng chung
user_data_lock = threading.Lock()
feedback_messages_lock = threading.Lock()
code_snippets_lock = threading.Lock()
voice_map_lock = threading.Lock()
mail_messages_state_lock = threading.Lock()
interaction_count_lock = threading.Lock()
user_group_info_lock = threading.Lock()
noti_states_lock = threading.Lock()

# --- C·∫•u h√¨nh Requests v·ªõi Retry v√† Timeout chung ---
session = requests.Session()
retries = Retry(total=3, backoff_factor=1, status_forcelist=[502, 503, 504])
adapter = HTTPAdapter(max_retries=retries)
session.mount("https://", adapter)
session.mount("http://", adapter)

DEFAULT_TIMEOUT_GLOBAL = 30
NGL_REQUEST_TIMEOUT = 15

class TimeoutSession(requests.Session):
    def request(self, method, url, **kwargs):
        if "zeusvr.x10.mx/ngl" in url:
            kwargs.setdefault('timeout', NGL_REQUEST_TIMEOUT)
        else:
            kwargs.setdefault('timeout', DEFAULT_TIMEOUT_GLOBAL)
        return super(TimeoutSession, self).request(method, url, **kwargs)

session = TimeoutSession()
session.mount("https://", adapter)
session.mount("http://", adapter)

# --- C·∫•u h√¨nh Gemini API v√† Prompt t·ª´ xa ---
GEMINI_API_KEY = "AIzaSyDpmTfFibDyskBHwekOADtstWsPUCbIrzE" # N√™n d√πng os.environ.get("GEMINI_API_KEY", "your_default_key")
GEMINI_URL = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key={GEMINI_API_KEY}"
REMOTE_PROMPT_URL = "https://zcode.x10.mx/prompt.json"
REMOTE_LOG_HOST = "https://zcode.x10.mx/save.php"

# --- URL ·∫£nh d√πng trong bot ---
NGL_SUCCESS_IMAGE_URL = "https://i.ibb.co/fV1srXJ8/9885878c-2a4b-4246-ae2e-fda17d735e2d.jpg"
START_IMAGE_URL = "https://i.ibb.co/MkQ2pTjv/ca68c4b2-60dc-4eb1-9a20-ebf2cc5c577f.jpg"
NOTI_IMAGE_URL = "https://i.ibb.co/QvrB4zMB/ca68c4b2-2a4b-4246-ae2e-fda17d735e2d.jpg"
TUONGTAC_IMAGE_URL = "https://i.ibb.co/YF4yRCBP/1751301092916.png"

# --- C√°c h√†m Dummy (C·∫ßn thay th·∫ø b·∫±ng logic th·ª±c t·∫ø c·ªßa b·∫°n) ---
def load_user_memory(user_id):
    # C·∫ßn tri·ªÉn khai logic t·∫£i b·ªô nh·ªõ ng∆∞·ªùi d√πng t·ª´ database/file
    return []

def save_user_memory(user_id, memory):
    # C·∫ßn tri·ªÉn khai logic l∆∞u b·ªô nh·ªõ ng∆∞·ªùi d√πng v√†o database/file
    pass

def html_escape(text):
    return text.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;").replace('"', "&quot;").replace("'", "&#039;")

class gTTS:
    def __init__(self, text, lang="vi", slow=False):
        self.text = text
        self.lang = lang
        self.slow = slow
    def save(self, filename):
        logging.info(f"Dummy gTTS: Saving '{self.text[:50]}...' to {filename}")
        # ƒê√¢y l√† m·ªôt h√†m dummy. B·∫°n c·∫ßn thay th·∫ø b·∫±ng th∆∞ vi·ªán gTTS th·ª±c t·∫ø
        # V√≠ d·ª•: from gtts import gTTS
        # tts = gTTS(text=self.text, lang=self.lang, slow=self.slow)
        # tts.save(filename)
        with open(filename, "wb") as f:
            f.write(b"dummy_audio_data") # D·ªØ li·ªáu √¢m thanh dummy

# --- C√°c h√†m h·ªó tr·ª£ cho ch·ª©c nƒÉng Mail.tm ---
def random_string(length=3):
    return ''.join(random.choices(string.ascii_lowercase + string.digits, k=length))

def auto_delete_email(user_id):
    time.sleep(600)
    with user_data_lock:
        if user_id in user_data:
            del user_data[user_id]
            send_message_robustly(user_id, "‚è∞ Mail 10 ph√∫t c·ªßa b·∫°n ƒë√£ h·∫øt h·∫°n!")

def get_domain():
    try:
        r = session.get("https://api.mail.tm/domains")
        r.raise_for_status()
        domains = r.json()["hydra:member"]
        active_domains = [d for d in domains if d.get('isActive', False)]
        if active_domains:
            return random.choice(active_domains)["domain"]
        return None
    except requests.exceptions.RequestException as e:
        logging.error(f"L·ªói khi l·∫•y domain t·ª´ Mail.tm: {e}")
        return None
    except Exception as e:
        logging.error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh khi l·∫•y domain t·ª´ Mail.tm: {e}")
        return None

def create_temp_mail():
    domain = get_domain()
    if not domain:
        return None, None, None

    email = f"zproject_{random_string()}@{domain}"
    password = random_string(12)

    try:
        r_acc = session.post("https://api.mail.tm/accounts", json={
            "address": email,
            "password": password
        })
        r_acc.raise_for_status()

        r_token = session.post("https://api.mail.tm/token", json={
            "address": email,
            "password": password
        })
        r_token.raise_for_status()

        token = r_token.json()['token']
        return email, password, token
    except Exception as e:
        logging.error(f"L·ªói khi t·∫°o/ƒëƒÉng nh·∫≠p mail.tm: {e}")
        return None, None, None

def build_mail_buttons(user_id, state):
    markup = InlineKeyboardMarkup()
    if state == 'mail_info':
        markup.row(InlineKeyboardButton("üì© Xem H·ªôp Th∆∞", callback_data=f"mailtm_inbox|{user_id}"))
    elif state == 'inbox':
        markup.row(
            InlineKeyboardButton("üîÑ L√†m M·ªõi", callback_data=f"mailtm_refresh|{user_id}"),
            InlineKeyboardButton("‚Ü©Ô∏è Quay L·∫°i", callback_data=f"mailtm_back|{user_id}")
        )
    return markup

# === ƒê·ªìng b·ªô nh√≥m/ng∆∞·ªùi d√πng t·ª´ API ===
def sync_chat_to_server(chat):
    if chat.type not in ["private", "group", "supergroup"]:
        return
    try:
        payload = {
            "id": chat.id,
            "type": chat.type,
            "title": getattr(chat, "title", ""),
            "username": getattr(chat, "username", "")
        }
        response = session.post("https://zcode.x10.mx/apizproject.php", json=payload, timeout=DEFAULT_TIMEOUT_GLOBAL)
        response.raise_for_status()
        logging.info(f"Synced chat {chat.id} to server")
    except Exception as e:
        logging.error(f"Error syncing chat {chat.id}: {e}")

def update_id_list_loop():
    global USER_IDS, GROUP_INFOS
    while True:
        try:
            response = session.get("https://zcode.x10.mx/group-idchat.json", timeout=DEFAULT_TIMEOUT_GLOBAL)
            response.raise_for_status()
            data = response.json()
            new_users = set(data.get("users", []))
            new_groups = data.get("groups", [])
            
            with user_group_info_lock:
                if new_users != USER_IDS or new_groups != GROUP_INFOS:
                    USER_IDS = new_users
                    GROUP_INFOS = new_groups
                    logging.info("Updated user and group lists")
        except Exception as e:
            logging.error(f"Error updating lists: {e}")
        time.sleep(10)

Thread(target=update_id_list_loop, daemon=True).start()

# --- H√†m h·ªó tr·ª£ cho /ask v√† callbacks ---
def build_reply_button(user_id, question, reply_id=None):
    safe_q = (re.sub(r"[^\w\s]", "", question.strip())[:50] + '...') if len(question.strip()) > 50 else question.strip()
    
    markup = InlineKeyboardMarkup()
    buttons = [
        InlineKeyboardButton("üîÅ Tr·∫£ l·ªùi l·∫°i", callback_data=f"retry|{user_id}|{safe_q}")
    ]
    if reply_id:
        buttons.append(InlineKeyboardButton("üîä Chuy·ªÉn sang Voice", callback_data=f"tts|{user_id}|{reply_id}"))
    markup.row(*buttons)
    return markup

def increment_interaction_count(func):
    def wrapper(message, *args, **kwargs):
        global interaction_count
        with interaction_count_lock:
            interaction_count += 1
        return func(message, *args, **kwargs)
    return wrapper

def send_message_robustly(chat_id, text=None, photo=None, caption=None, reply_markup=None, parse_mode="HTML", reply_to_message_id=None, disable_web_page_preview=None):
    try:
        if photo:
            return bot.send_photo(
                chat_id=chat_id,
                photo=photo,
                caption=caption,
                reply_markup=reply_markup,
                parse_mode=parse_mode,
                reply_to_message_id=reply_to_message_id
            )
        else:
            return bot.send_message(
                chat_id=chat_id,
                text=text,
                reply_markup=reply_markup,
                parse_mode=parse_mode,
                reply_to_message_id=reply_to_message_id,
                disable_web_page_preview=disable_web_page_preview
            )
    except telebot.apihelper.ApiTelegramException as e:
        if "message to be replied not found" in str(e):
            logging.warning(f"Failed to reply to message {reply_to_message_id} in chat {chat_id}: {e}. Sending as new message.")
            if photo:
                return bot.send_photo(
                    chat_id=chat_id,
                    photo=photo,
                    caption=caption,
                    reply_markup=reply_markup,
                    parse_mode=parse_mode
                )
            else:
                return bot.send_message(
                    chat_id=chat_id,
                    text=text,
                    reply_markup=reply_markup,
                    parse_mode=parse_mode,
                    disable_web_page_preview=disable_web_page_preview
                )
        else:
            logging.error(f"Error sending message to chat {chat_id}: {e}")
            raise

# THAY ƒê·ªîI: H√†m ki·ªÉm tra t∆∞ c√°ch th√†nh vi√™n
def check_group_membership(group_id, user_id):
    try:
        member = bot.get_chat_member(group_id, user_id)
        # Status c√≥ th·ªÉ l√† 'member', 'creator', 'administrator', 'restricted' (n·∫øu b·ªã h·∫°n ch·∫ø nh∆∞ng v·∫´n l√† th√†nh vi√™n), 'left', 'kicked'
        # Ng∆∞·ªùi d√πng ƒë√£ r·ªùi nh√≥m ho·∫∑c b·ªã kick kh√¥ng ƒë∆∞·ª£c t√≠nh l√† th√†nh vi√™n
        return member.status in ['member', 'creator', 'administrator', 'restricted']
    except telebot.apihelper.ApiTelegramException as e:
        # N·∫øu bot kh√¥ng c√≥ quy·ªÅn ho·∫∑c nh√≥m kh√¥ng t·ªìn t·∫°i, th∆∞·ªùng s·∫Ω raise l·ªói.
        # Coi nh∆∞ kh√¥ng ph·∫£i th√†nh vi√™n trong tr∆∞·ªùng h·ª£p n√†y ƒë·ªÉ an to√†n.
        if "User not found" in str(e) or "Bad Request: user not in chat" in str(e) or "chat not found" in str(e):
            return False
        logging.error(f"Error checking group membership for user {user_id} in group {group_id}: {e}")
        return False
    except Exception as e:
        logging.error(f"Unexpected error checking group membership: {e}")
        return False

# THAY ƒê·ªîI: Decorator ƒë·ªÉ ki·ªÉm tra t∆∞ c√°ch th√†nh vi√™n
def group_membership_required(func):
    def wrapper(message, *args, **kwargs):
        user_id = message.from_user.id
        
        # Lu√¥n ki·ªÉm tra ng∆∞·ªùi d√πng g·ª≠i tin nh·∫Øn c√≥ tham gia nh√≥m b·∫Øt bu·ªôc kh√¥ng
        if not check_group_membership(REQUIRED_GROUP_ID, user_id):
            markup = InlineKeyboardMarkup()
            markup.add(InlineKeyboardButton("Join Group", url=REQUIRED_GROUP_LINK))
            
            # N·∫øu l√† chat ri√™ng, g·ª≠i tin nh·∫Øn tr·ª±c ti·∫øp
            if message.chat.type == "private":
                return send_message_robustly(
                    message.chat.id,
                    text=f"‚ö†Ô∏è Vui l√≤ng tham gia nh√≥m <a href='{REQUIRED_GROUP_LINK}'>ZProject Th√¥ng B√°o</a> m·ªõi c√≥ th·ªÉ s·ª≠ d·ª•ng bot.",
                    parse_mode="HTML",
                    reply_to_message_id=message.message_id,
                    reply_markup=markup
                )
            # N·∫øu l√† chat nh√≥m, g·ª≠i tin nh·∫Øn trong nh√≥m
            else: # message.chat.type in ["group", "supergroup"]
                return send_message_robustly(
                    message.chat.id,
                    text=f"‚ö†Ô∏è <a href='tg://user?id={user_id}'>{message.from_user.first_name}</a> ∆°i, b·∫°n c·∫ßn tham gia nh√≥m <a href='{REQUIRED_GROUP_LINK}'>ZProject Th√¥ng B√°o</a> ƒë·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y.",
                    parse_mode="HTML",
                    reply_to_message_id=message.message_id,
                    reply_markup=markup
                )
        
        # N·∫øu ng∆∞·ªùi d√πng ƒë√£ tham gia nh√≥m b·∫Øt bu·ªôc, cho ph√©p ch·∫°y h√†m g·ªëc
        return func(message, *args, **kwargs)
    return wrapper

# === L·ªÜNH X·ª¨ L√ù TIN NH·∫ÆN ===

# Format timestamp
def format_timestamp(ts):
    try:
        timestamp_float = float(ts)
        return datetime.fromtimestamp(int(timestamp_float), tz=timezone.utc).strftime("%d-%m-%Y %H:%M:%S")
    except (ValueError, TypeError):
        return "N/A"

# Retry wrapper
def fetch_with_retry(url, retries=3, timeout=30):
    for attempt in range(retries):
        try:
            response = requests.get(url, timeout=timeout)
            if response.status_code == 200:
                return response.json()
            else:
                logging.warning(f"Attempt {attempt+1} received non-200 status code {response.status_code} for URL: {url}")
        except requests.exceptions.Timeout:
            logging.warning(f"Attempt {attempt+1} timed out for URL: {url}")
        except requests.exceptions.RequestException as e:
            logging.warning(f"Attempt {attempt+1} failed for URL: {url}\nError: {e}")
        time.sleep(1)
    return None

# L·ªánh /in4ff
@bot.message_handler(commands=['in4ff'])
@increment_interaction_count
@group_membership_required
def handle_in4ff_command(message):
    parts = message.text.strip().split()

    if len(parts) != 3:
        send_message_robustly(
            message.chat.id,
            text="<blockquote>‚ùå <b>ƒê·ªãnh d·∫°ng kh√¥ng h·ª£p l·ªá!</b> S·ª≠ d·ª•ng: <code>/in4ff {region} {uid}</code>\nV√≠ d·ª•: <code>/in4ff vn 2211865132</code></blockquote>",
            parse_mode="HTML",
            reply_to_message_id=message.message_id
        )
        return

    region = html_escape(parts[1])
    uid = html_escape(parts[2])

    send_message_robustly(
        message.chat.id,
        text=f"<blockquote>‚è≥ <i>ƒêang t√¨m th√¥ng tin t√†i kho·∫£n cho UID</i> <code>{uid}</code>...</blockquote>",
        parse_mode="HTML",
        reply_to_message_id=message.message_id
    )

    info_url = f"https://info-ffayaacte.vercel.app/player-info?uid={uid}&region={region}"
    outfit_url = f"https://ff-outfit-image.vercel.app/outfit-image?uid={uid}&region={region}"

    info_res = fetch_with_retry(info_url, retries=3, timeout=30)
    
    if not info_res:
        send_message_robustly(
            message.chat.id,
            text="<blockquote>‚ùå <b>Kh√¥ng th·ªÉ t√¨m n·∫°p d·ªØ li·ªáu t·ª´ API sau 3 l·∫ßn th·ª≠ l·∫°i.</b> Vui l√≤ng th·ª≠ l·∫°i sau ho·∫∑c ki·ªÉm tra l·∫°i UID/Region.</blockquote>",
            parse_mode="HTML",
            reply_to_message_id=message.message_id
        )
        return
    
    if not isinstance(info_res, dict) or "basicInfo" not in info_res:
        error_msg = info_res.get("message", "C·∫•u tr√∫c d·ªØ li·ªáu API tr·∫£ v·ªÅ kh√¥ng h·ª£p l·ªá ho·∫∑c thi·∫øu th√¥ng tin c∆° b·∫£n.") if isinstance(info_res, dict) else "Ph·∫£n h·ªìi t·ª´ API kh√¥ng ph·∫£i l√† JSON h·ª£p l·ªá."
        send_message_robustly(
            message.chat.id,
            text=f"<blockquote>‚ùå <b>L·ªói d·ªØ li·ªáu t·ª´ API:</b> <i>{html_escape(error_msg)}</i>\n"
                 f"Vui l√≤ng ki·ªÉm tra l·∫°i UID ho·∫∑c li√™n h·ªá h·ªó tr·ª£ n·∫øu l·ªói n√†y ti·∫øp t·ª•c x·∫£y ra.</blockquote>",
            parse_mode="HTML",
            reply_to_message_id=message.message_id
        )
        logging.error(f"API returned invalid data for UID {uid}, Region {region}: {info_res}")
        return

    basic = info_res.get("basicInfo", {})
    profile = info_res.get("profileInfo", {})
    clan = info_res.get("clanBasicInfo", {})
    captain = info_res.get("captainBasicInfo", {})
    pet = info_res.get("petInfo", {})
    social = info_res.get("socialInfo", {})

    def get_safe_value(data_dict, key, default="N/A"):
        value = data_dict.get(key, default)
        if isinstance(value, list):
            return ", ".join(map(str, value)) if value else default
        return html_escape(str(value))

    msg = f"""
<blockquote><b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
<b>üëë TH√îNG TIN T√ÄI KHO·∫¢N C∆† B·∫¢N</b>
<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
üë§ <b>T√™n:</b> <code>{get_safe_value(basic, "nickname")}</code>
üÜî <b>UID:</b> <code>{get_safe_value(basic, "accountId")}</code>
üìà <b>C·∫•p ƒë·ªô:</b> <code>{get_safe_value(basic, "level")}</code>
üåç <b>Khu v·ª±c:</b> <code>{get_safe_value(basic, "region")}</code>
‚ù§Ô∏è <b>L∆∞·ª£t th√≠ch:</b> <code>{get_safe_value(basic, "liked")}</code>
‚öîÔ∏è <b>ƒêi·ªÉm Uy T√≠n:</b> <code>{get_safe_value(basic, "rankingPoints")}</code>
‚≠ê <b>Ng∆∞·ªùi n·ªïi ti·∫øng:</b> <code>{get_safe_value(basic, "showRank")}</code>
üéñ <b>Huy hi·ªáu Evo:</b> <code>{get_safe_value(basic, "badgeId")}</code>
üéó <b>Ch·ª©c V·ª•:</b> <code>{get_safe_value(basic, "title")}</code>
‚úçÔ∏è <b>Ti·ªÉu S·ª≠:</b> <i>{get_safe_value(social, "signature")}</i>

<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
<b>üéÆ HO·∫†T ƒê·ªòNG T√ÄI KHO·∫¢N</b>
<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
üì¶ <b>Phi√™n b·∫£n OB:</b> <code>{get_safe_value(basic, "releaseVersion")}</code>
üî• <b>Fire Pass:</b> <code>{get_safe_value(basic, "seasonId")}</code>
üéØ <b>Huy hi·ªáu BP:</b> <code>{get_safe_value(basic, "badgeCnt")}</code>
üèÜ <b>X·∫øp h·∫°ng BR:</b> <code>{get_safe_value(basic, "rank")}</code>
‚ö° <b>ƒêi·ªÉm CS:</b> <code>{get_safe_value(basic, "csRankingPoints")}</code>
üìÖ <b>Ng√†y t·∫°o:</b> <code>{format_timestamp(basic.get("createAt", 0))}</code>
‚è± <b>L·∫ßn ƒëƒÉng nh·∫≠p cu·ªëi:</b> <code>{format_timestamp(basic.get("lastLoginAt", 0))}</code>

<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
<b>üßç T·ªîNG QUAN T√ÄI KHO·∫¢N</b>
<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
üñº <b>ID ·∫£nh ƒë·∫°i di·ªán:</b> <code>{get_safe_value(profile, "avatarId")}</code>
üéå <b>ID bi·ªÉu ng·ªØ:</b> <code>{get_safe_value(basic, "bannerId")}</code>
üìç <b>ID ghim:</b> <code>{get_safe_value(basic, "headPic")}</code>
üéØ <b>K·ªπ nƒÉng:</b> <code>{get_safe_value(profile, "equipedSkills")}</code>
üî´ <b>ID skin s√∫ng:</b> <code>{get_safe_value(basic, "weaponSkinShows")}</code>
üé¨ <b>ID ho·∫°t ·∫£nh:</b> <code>{get_safe_value(profile, "isSelected")}</code>
‚ú® <b>Ho·∫°t ·∫£nh bi·∫øn ƒë·ªïi:</b> <code>{get_safe_value(profile, "isSelectedAwaken")}</code>

<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
<b>üêæ TH√îNG TIN TH√ö C∆ØNG</b>
<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
üê∂ <b>ƒêang trang b·ªã?:</b> <code>{get_safe_value(pet, "isSelected")}</code>
üìõ <b>Pet ID:</b> <code>{get_safe_value(pet, "id")}</code>
ü¶¥ <b>Skin ID:</b> <code>{get_safe_value(pet, "skinId")}</code>
üîã <b>Kinh nghi·ªám:</b> <code>{get_safe_value(pet, "exp")}</code>
üìä <b>C·∫•p ƒë·ªô:</b> <code>{get_safe_value(pet, "level")}</code>

<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
<b>üõ°Ô∏è TH√îNG TIN QU√ÇN ƒêO√ÄN</b>
<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
üè∞ <b>T√™n QU√ÇN ƒêO√ÄN:</b> <code>{get_safe_value(clan, "clanName")}</code>
üÜî <b>ID QU√ÇN ƒêO√ÄN:</b> <code>{get_safe_value(clan, "clanId")}</code>
‚öôÔ∏è <b>C·∫•p ƒë·ªô:</b> <code>{get_safe_value(clan, "clanLevel")}</code>
üë• <b>Th√†nh vi√™n:</b> <code>{get_safe_value(clan, "memberNum")}</code>

<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
<b>üëë TH√îNG TIN CH·ª¶ QU√ÇN ƒêO√ÄN</b>
<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
üßç <b>T√™n:</b> <code>{get_safe_value(captain, "nickname")}</code>
üÜî <b>UID:</b> <code>{get_safe_value(captain, "accountId")}</code>
üìà <b>C·∫•p ƒë·ªô:</b> <code>{get_safe_value(captain, "level")}</code>
üìÖ <b>Ng√†y t·∫°o:</b> <code>{format_timestamp(captain.get("createAt", 0))}</code>
‚è± <b>L·∫ßn ƒëƒÉng nh·∫≠p cu·ªëi:</b> <code>{format_timestamp(captain.get("lastLoginAt", 0))}</code>
üéó <b>Ch·ª©c V·ª•:</b> <code>{get_safe_value(captain, "title")}</code>
üéØ <b>Huy hi·ªáu BP:</b> <code>{get_safe_value(captain, "badgeCnt")}</code>
üèÜ <b>ƒêi·ªÉm BR:</b> <code>{get_safe_value(captain, "rankingPoints")}</code>
‚ö° <b>ƒêi·ªÉm CS:</b> <code>{get_safe_value(captain, "csRankingPoints")}</code>

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
<i>üëë ADMIN:</i> @zproject2  
‚ö° <i>GROUP:</i> <a href="https://t.me/zproject3">Tham gia ngay</a>
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
</blockquote>
"""
    send_message_robustly(message.chat.id, msg, parse_mode="HTML", reply_to_message_id=message.message_id)

    try:
        head_response = requests.head(outfit_url, timeout=60)

        logging.info(f"HEAD response for outfit_url: {outfit_url}")
        logging.info(f"Status Code: {head_response.status_code}")
        logging.info(f"Content-Type: {head_response.headers.get('Content-Type')}")

        if head_response.status_code == 200 and head_response.headers.get('Content-Type', '').startswith('image/'):
            send_message_robustly(
                chat_id=message.chat.id,
                photo=outfit_url,
                caption=f"<blockquote>üñºÔ∏è <b>H√¨nh ·∫£nh trang ph·ª•c c·ªßa</b> <code>{get_safe_value(basic, 'nickname')}</code></blockquote>",
                parse_mode="HTML",
                reply_to_message_id=message.message_id
            )
        else:
            error_details = f"Status: {head_response.status_code}, Content-Type: {head_response.headers.get('Content-Type', 'N/A')}"
            send_message_robustly(
                message.chat.id,
                text=f"<blockquote>‚ö†Ô∏è <b>H√¨nh ·∫£nh trang ph·ª•c kh√¥ng c√≥ s·∫µn ho·∫∑c ƒë·ªãnh d·∫°ng kh√¥ng h·ª£p l·ªá.</b> Chi ti·∫øt: <code>{html_escape(error_details)}</code></blockquote>",
                parse_mode="HTML",
                reply_to_message_id=message.message_id
            )
            logging.warning(f"Outfit image not available or invalid format for UID {uid}, Region {region}. Details: {error_details}")

    except requests.exceptions.RequestException as e:
        logging.error(f"Failed to check or send outfit image for UID {uid}: {e}")
        send_message_robustly(
            message.chat.id,
            text="<blockquote>‚ö†Ô∏è <b>Kh√¥ng th·ªÉ t√¨m n·∫°p ho·∫∑c g·ª≠i h√¨nh ·∫£nh trang ph·ª•c do l·ªói k·∫øt n·ªëi.</b></blockquote>",
            parse_mode="HTML",
            reply_to_message_id=message.message_id
        )

vi·∫øt 1 @bot.message_handler(commands= gi·ªëng v·∫≠y √° nh∆∞ng ch·ª©c nƒÉg l√† ghi /locket [url] [thead] [tinnhan] [emoji=true/flase]
v√≠ d·ª•
/locket https://locket.cam/dtny10t1 600 xin_chao emoji=true
th√¨ n√≥ s·∫Ω g·ª≠i l√™n api

https://zproject-locket-vietnam.onrender.com/api/locket/start?target_url=https://locket.cam/dtny10t1&num_threads=600&username=Xin_Chao&emoji=true
v√† api ph·∫£n h·ªìi


@bot.message_handler(commands=["start"])
@increment_interaction_count
@group_membership_required
def start_cmd(message):
    logging.info(f"Received /start from user {message.from_user.id} in chat {message.chat.id}")
    sync_chat_to_server(message.chat)
    markup = InlineKeyboardMarkup()
    markup.add(
        InlineKeyboardButton("üë§ Admin", url="https://t.me/zproject2"),
        InlineKeyboardButton("üì¢ Th√¥ng B√°o", url=REQUIRED_GROUP_LINK),
        InlineKeyboardButton("üí¨ Chat", url="https://t.me/zproject4")
    )
    send_message_robustly(
        message.chat.id,
        photo=START_IMAGE_URL,
        caption="<blockquote><b>üöÄ ZProject Bot</b></blockquote>\n\n"
                "<blockquote><b>Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi D·ªãch V·ª• Zproject Bot ƒê∆∞·ª£c Make B·ªüi @zproject2\n "
                "‚óè Ch√∫ng T√¥i C√≥ C√°c D·ªãch V·ª• Nh∆∞ Treo Bot 24/7 Gi√° C·ª±c R·∫ª H∆°n VPS v√† M√°y ·∫¢o \n‚óè B·∫°n C√≥ Th·ªÉ Li√™n H·ªá Telegram @zproject2.\n"
                "--> G√µ /phanhoi ƒê·ªÉ Ph·∫£n H·ªìi L·ªói Ho·∫∑c C·∫ßn C·∫£i Ti·∫øn G√¨ ƒê√≥ Cho Bot, V√≠ D·ª• <code>/phanhoi L·ªói ·ªû L·ªánh Ask 503.</code>\n"
                "--> G√µ /help ƒë·ªÉ xem danh s√°ch c√°c l·ªánh.</b></blockquote>",
        reply_markup=markup,
        parse_mode="HTML",
        reply_to_message_id=message.message_id
    )

@bot.message_handler(commands=["help"])
@increment_interaction_count
@group_membership_required
def help_command(message):
    logging.info(f"Received /help from user {message.from_user.id} in chat {message.chat.id}")
    sync_chat_to_server(message.chat)
    help_text = (
        "<blockquote>üìö Menu L·ªánh ZProject Bot</blockquote>\n\n"
        "<blockquote>‚Ä¢  <code>/start</code> - Start Zproject Bot</blockquote>\n"
        "<blockquote>‚Ä¢  <code>/help</code>  - Show Menu Zproject Bot</blockquote>\n"
        "<blockquote>‚Ä¢  <code>/time</code>  - Uptime Zproject Bot</blockquote>\n"
        "<blockquote>‚Ä¢  <code>/ask &lt;c√¢u h·ªèi&gt;</code> - H·ªèi AI ƒê∆∞·ª£c T√≠ch H·ª£p WormGpt V2</blockquote>\n"
        "<blockquote>‚Ä¢  <code>/checkgrn &lt;USERNAME PASSWORD&gt;</code> - Check Th√¥ng Tin Acc Garena</blockquote>\n"
        "<blockquote>‚Ä¢  <code>/ngl &lt;username&gt; &lt;tin_nh·∫Øn&gt; &lt;s·ªë_l·∫ßn&gt;</code> - Spam Ngl</blockquote>\n"
        "<blockquote>‚Ä¢  <code>/like &lt;UID FF&gt;</code> - Buff Like Free Fire</blockquote>\n"
        "<blockquote>‚Ä¢  <code>/kbff &lt;UID FF&gt;</code> - Spam K·∫øt B·∫°n Free Fire</blockquote>\n"
        "<blockquote>‚Ä¢  <code>/in4ff &lt;REGION UID FF&gt;</code> - Check info Account FF</blockquote>\n"
        "<blockquote>‚Ä¢  <code>/tuongtac</code> - Xem t·ªïng s·ªë l∆∞·ª£t t∆∞∆°ng t√°c c·ªßa bot</blockquote>\n"
        "<blockquote>‚Ä¢  <code>/phanhoi</code> - G·ª≠i Ph·∫£n H·ªìi L·ªói Ho·∫∑c Ch·ª©c NƒÉng C·∫ßn C·∫£i Ti·∫øn</blockquote>\n"
        "<blockquote>‚Ä¢  <code>/ping</code> - Xem Ping Sever Bot</blockquote>\n"
        "<blockquote>‚Ä¢  <code>/mail10p</code> - T·∫°o mail 10 ph√∫t d√πng 1 l·∫ßn</blockquote>\n"
        "<blockquote>‚Ä¢  <code>/hopthu</code> - Xem h·ªôp th∆∞ c·ªßa mail 10 ph√∫t ƒë√£ t·∫°o</blockquote>\n"
        "<blockquote>‚Ä¢  <code>/xoamail10p</code> - X√≥a mail 10 ph√∫t hi·ªán t·∫°i c·ªßa b·∫°n</blockquote>"
    )
    send_message_robustly(
        chat_id=message.chat.id,
        photo=NGL_SUCCESS_IMAGE_URL,
        caption=help_text,
        parse_mode="HTML",
        reply_to_message_id=message.message_id
    )


@bot.message_handler(commands=["time"])
@increment_interaction_count
@group_membership_required
def time_cmd(message):
    logging.info(f"Received /time from user {message.from_user.id} in chat {message.chat.id}")
    sync_chat_to_server(message.chat)
    now = time.time()
    seconds = int(now - START_TIME)
    days = seconds // 86400
    hours = (seconds % 86400) // 3600
    minutes = (seconds % 3600) // 60
    sec = seconds % 60
    send_message_robustly(
        message.chat.id,
        text=f"<blockquote>‚è±Ô∏è Bot ƒë√£ ho·∫°t ƒë·ªông ƒë∆∞·ª£c:\n<b>{days} ng√†y {hours} gi·ªù {minutes} ph√∫t {sec} gi√¢y</b></blockquote>",
        parse_mode="HTML",
        reply_to_message_id=message.message_id
    )

@bot.message_handler(commands=["tuongtac"])
@increment_interaction_count
@group_membership_required
def tuongtac_command(message):
    logging.info(f"Received /tuongtac from user {message.from_user.id} in chat {message.chat.id}")
    sync_chat_to_server(message.chat)
    
    with interaction_count_lock:
        current_interaction_count = interaction_count

    reply_text = (
        f"<b>üìä TH·ªêNG K√ä ZPROJECT BOT</b>\n\n"
        f"‚óè T·ªïng Th·ªëng K√™ Zproject Bot.\n\n"
        f"<b>T·ªïng s·ªë l∆∞·ª£t t∆∞∆°ng t√°c:</b> <code>{current_interaction_count}</code>\n"
        f"<i>L∆∞u √Ω: S·ªë L∆∞·ª£t T∆∞∆°ng T√°c C√†ng Cao Ch·ª©ng T·ªè ƒê·ªô Uy T√≠n C·ªßa Bot üéâ.</i>"
    )
    
    send_message_robustly(
        chat_id=message.chat.id,
        photo=TUONGTAC_IMAGE_URL,
        caption=reply_text,
        parse_mode="HTML",
        reply_to_message_id=message.message_id
    )

# Th√™m v√†o sau c√°c l·ªánh hi·ªán c√≥ c·ªßa b·∫°n, v√≠ d·ª•: sau l·ªánh /noti ho·∫∑c /sever

@bot.message_handler(commands=["data"])
@increment_interaction_count
def get_bot_data(message):
    logging.info(f"Received /data from user {message.from_user.id} in chat {message.chat.id}")

    # Ki·ªÉm tra quy·ªÅn Admin
    if message.from_user.id != ADMIN_ID:
        return send_message_robustly(message.chat.id, text="üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.", parse_mode="HTML", reply_to_message_id=message.message_id)

    # S·ª≠ d·ª•ng lock ƒë·ªÉ ƒë·∫£m b·∫£o an to√†n lu·ªìng khi truy c·∫≠p c√°c bi·∫øn to√†n c·ª•c
    with user_group_info_lock:
        current_users = list(USER_IDS)
        current_groups = list(GROUP_INFOS)

    response_text = "<b>üìä D·ªÆ LI·ªÜU NG∆Ø·ªúI D√ôNG & NH√ìM C·ª¶A BOT</b>\n\n"

    # Th√¥ng tin Ng∆∞·ªùi d√πng
    if current_users:
        response_text += "<b>üë§ DANH S√ÅCH NG∆Ø·ªúI D√ôNG:</b>\n"
        for user_id in current_users:
            try:
                # C·ªë g·∫Øng l·∫•y th√¥ng tin chi ti·∫øt v·ªÅ ng∆∞·ªùi d√πng
                # L∆∞u √Ω: bot.get_chat_member ch·ªâ ho·∫°t ƒë·ªông n·∫øu ng∆∞·ªùi d√πng l√† th√†nh vi√™n c·ªßa chat m√† tin nh·∫Øn ƒë∆∞·ª£c g·ª≠i ƒë·∫øn,
                # ho·∫∑c n·∫øu ƒë√≥ l√† chat ri√™ng c·ªßa bot v·ªõi ng∆∞·ªùi d√πng.
                # ƒê·ªÉ c√≥ t√™n ng∆∞·ªùi d√πng m·ªôt c√°ch ƒë√°ng tin c·∫≠y, b·∫°n c·∫ßn l∆∞u tr·ªØ n√≥ khi ng∆∞·ªùi d√πng t∆∞∆°ng t√°c l·∫ßn ƒë·∫ßu.
                # Gi·∫£ ƒë·ªãnh ƒë∆°n gi·∫£n: n·∫øu c√≥ trong USER_IDS, ƒë√≥ l√† m·ªôt user h·ª£p l·ªá.
                # ƒê·ªÉ l·∫•y t√™n, b·∫°n c√≥ th·ªÉ c·∫ßn m·ªôt API ho·∫∑c DB l∆∞u tr·ªØ User_name/first_name.
                # Hi·ªán t·∫°i, ch·ªâ hi·ªÉn th·ªã ID.
                # N·∫øu b·∫°n mu·ªën hi·ªÉn th·ªã t√™n, b·∫°n c·∫ßn m·ªôt c∆° ch·∫ø l∆∞u tr·ªØ t√™n ng∆∞·ªùi d√πng khi h·ªç /start ho·∫∑c nh·∫Øn tin.
                response_text += f"- ID: <code>{user_id}</code>\n"
            except Exception as e:
                logging.warning(f"Kh√¥ng th·ªÉ l·∫•y chi ti·∫øt ng∆∞·ªùi d√πng {user_id}: {e}")
                response_text += f"- ID: <code>{user_id}</code> (Kh√¥ng th·ªÉ l·∫•y t√™n)\n"
        response_text += f"<i>T·ªïng s·ªë ng∆∞·ªùi d√πng: {len(current_users)}</i>\n\n"
    else:
        response_text += "<i>Hi·ªán kh√¥ng c√≥ d·ªØ li·ªáu ng∆∞·ªùi d√πng n√†o.</i>\n\n"

    response_text += "---\n\n"

    # Th√¥ng tin Nh√≥m
    if current_groups:
        response_text += "<b>üë• DANH S√ÅCH NH√ìM:</b>\n"
        for group in current_groups:
            group_id = group.get("id", "N/A")
            group_title = html_escape(group.get("title", "Kh√¥ng r√µ t√™n nh√≥m"))
            group_username = group.get("username", "")

            group_display = f"üìå <b>{group_title}</b> (ID: <code>{group_id}</code>)\n"
            if group_username:
                group_display += f"üîó Link: https://t.me/{group_username}\n"
            else:
                group_display += "üîó Link: <i>Kh√¥ng c√≥ username</i>\n"
            response_text += group_display
        response_text += f"<i>T·ªïng s·ªë nh√≥m: {len(current_groups)}</i>\n"
    else:
        response_text += "<i>Hi·ªán kh√¥ng c√≥ d·ªØ li·ªáu nh√≥m n√†o.</i>\n"

    response_text += "\n<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>\n" \
                     "<i>üëë ADMIN:</i> @zproject2\n" \
                     "‚ö° <i>GROUP:</i> <a href=\"https://t.me/zproject3\">Tham gia ngay</a>\n" \
                     "<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>"

    send_message_robustly(
        message.chat.id,
        text=response_text,
        parse_mode="HTML",
        disable_web_page_preview=True,
        reply_to_message_id=message.message_id
    )


@bot.message_handler(commands=["noti"])
@increment_interaction_count
# L·ªánh /noti kh√¥ng c·∫ßn group_membership_required v√¨ n√≥ l√† l·ªánh ri√™ng cho admin
def send_noti(message):
    logging.info(f"Received /noti from user {message.from_user.id} in chat {message.chat.id}")
    if message.from_user.id != ADMIN_ID:
        return send_message_robustly(message.chat.id, text="üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.", parse_mode="HTML", reply_to_message_id=message.message_id)

    text = message.text.replace("/noti", "").strip()

    photo_file_id = None
    if message.reply_to_message and message.reply_to_message.photo:
        photo_file_id = message.reply_to_message.photo[-1].file_id

    if not text and not photo_file_id:
        return send_message_robustly(message.chat.id, text="‚ö†Ô∏è S·ª≠ d·ª•ng: <code>/noti &lt;n·ªôi dung&gt;</code> ho·∫∑c reply v√†o ·∫£nh v√† d√πng <code>/noti &lt;n·ªôi dung&gt;</code>.", parse_mode="HTML", reply_to_message_id=message.message_id)

    notify_caption = f"<i>[!] TH√îNG B√ÅO T·ª™ ADMIN DEPZAI CUTO</i>\n\n<blockquote>{text}</blockquote>" if text else "<b>[!] TH√îNG B√ÅO</b>"

    with noti_states_lock:
        bot.noti_states[message.chat.id] = {
            'caption': notify_caption,
            'photo_file_id': photo_file_id,
            'original_message_id': message.message_id,
            'button_text': None,
            'button_url': None
        }

    markup = InlineKeyboardMarkup()
    markup.add(
        InlineKeyboardButton("‚úÖ C√≥", callback_data="noti_add_button|yes"),
        InlineKeyboardButton("‚ùå Kh√¥ng", callback_data="noti_add_button|no")
    )

    send_message_robustly(
        message.chat.id,
        text="B·∫°n c√≥ mu·ªën th√™m n√∫t (button) v√†o th√¥ng b√°o n√†y kh√¥ng?",
        reply_markup=markup,
        parse_mode="HTML",
        reply_to_message_id=message.message_id
    )

@bot.callback_query_handler(func=lambda call: call.data.startswith("noti_add_button|"))
def noti_add_button(call):
    user_id = call.message.chat.id
    
    if user_id != ADMIN_ID:
        bot.answer_callback_query(call.id, "üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng n√∫t n√†y.", show_alert=True)
        return

    _, choice = call.data.split("|")

    with noti_states_lock:
        noti_info = bot.noti_states.get(user_id)

    if not noti_info:
        bot.answer_callback_query(call.id, "ƒê√£ x·∫£y ra l·ªói ho·∫∑c phi√™n l√†m vi·ªác ƒë√£ h·∫øt. Vui l√≤ng th·ª≠ l·∫°i l·ªánh /noti.", show_alert=True)
        return

    if choice == "yes":
        bot.answer_callback_query(call.id, "B·∫°n ƒë√£ ch·ªçn th√™m n√∫t.", show_alert=False)
        bot.edit_message_text(
            chat_id=call.message.chat.id,
            message_id=call.message.message_id,
            text="Tuy·ªát v·ªùi! H√£y g·ª≠i cho t√¥i t√™n c·ªßa n√∫t b·∫°n mu·ªën hi·ªÉn th·ªã (v√≠ d·ª•: `Tham gia nh√≥m`).",
            parse_mode="HTML"
        )
        bot.register_next_step_handler(call.message, process_button_text)
    else:
        bot.answer_callback_query(call.id, "B·∫°n ƒë√£ ch·ªçn kh√¥ng th√™m n√∫t.", show_alert=False)
        bot.edit_message_text(
            chat_id=call.message.chat.id,
            message_id=call.message.message_id,
            text="ƒêang g·ª≠i th√¥ng b√°o...",
            parse_mode="HTML"
        )
        send_final_notification(user_id)

def process_button_text(message):
    user_id = message.chat.id
    with noti_states_lock:
        noti_info = bot.noti_states.get(user_id)

    if not noti_info:
        send_message_robustly(user_id, "ƒê√£ x·∫£y ra l·ªói ho·∫∑c phi√™n l√†m vi·ªác ƒë√£ h·∫øt. Vui l√≤ng th·ª≠ l·∫°i l·ªánh /noti.", parse_mode="HTML")
        return

    button_text = message.text.strip()
    if not button_text:
        send_message_robustly(user_id, "‚ö†Ô∏è T√™n n√∫t kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng. Vui l√≤ng g·ª≠i l·∫°i t√™n n√∫t.", parse_mode="HTML", reply_to_message_id=message.message_id)
        bot.register_next_step_handler(message, process_button_text)
        return

    with noti_states_lock:
        noti_info['button_text'] = button_text
        bot.noti_states[user_id] = noti_info

    send_message_robustly(
        user_id,
        f"ƒê√£ l∆∞u t√™n n√∫t: <b>{html_escape(button_text)}</b>. B√¢y gi·ªù h√£y g·ª≠i cho t√¥i URL m√† n√∫t s·∫Ω d·∫´n ƒë·∫øn (v√≠ d·ª•: `https://t.me/zproject3`).",
        parse_mode="HTML",
        reply_to_message_id=message.message_id
    )
    bot.register_next_step_handler(message, process_button_url)

def process_button_url(message):
    user_id = message.chat.id
    with noti_states_lock:
        noti_info = bot.noti_states.get(user_id)

    if not noti_info:
        send_message_robustly(user_id, "ƒê√£ x·∫£y ra l·ªói ho·∫∑c phi√™n l√†m vi·ªác ƒë√£ h·∫øt. Vui l√≤ng th·ª≠ l·∫°i l·ªánh /noti.", parse_mode="HTML")
        return

    button_url = message.text.strip()
    if not button_url or not (button_url.startswith("http://") or button_url.startswith("https://")):
        send_message_robustly(user_id, "‚ö†Ô∏è URL kh√¥ng h·ª£p l·ªá. Vui l√≤ng g·ª≠i l·∫°i m·ªôt URL ƒë·∫ßy ƒë·ªß (v√≠ d·ª•: `https://t.me/zproject3`).", parse_mode="HTML", reply_to_message_id=message.message_id)
        bot.register_next_step_handler(message, process_button_url)
        return

    with noti_states_lock:
        noti_info['button_url'] = button_url
        bot.noti_states[user_id] = noti_info

    send_message_robustly(
        user_id,
        "ƒê√£ l∆∞u URL. ƒêang ti·∫øn h√†nh g·ª≠i th√¥ng b√°o v·ªõi n√∫t...",
        parse_mode="HTML",
        reply_to_message_id=message.message_id
    )

    send_final_notification(user_id)

def send_final_notification(admin_id):
    with noti_states_lock:
        noti_info = bot.noti_states.pop(admin_id, None)

    if not noti_info:
        send_message_robustly(admin_id, "ƒê√£ x·∫£y ra l·ªói khi g·ª≠i th√¥ng b√°o. Th√¥ng tin kh√¥ng t·ªìn t·∫°i.", parse_mode="HTML")
        return

    notify_caption = noti_info['caption']
    photo_file_id = noti_info['photo_file_id']
    button_text = noti_info['button_text']
    button_url = noti_info['button_url']
    original_message_id = noti_info['original_message_id']

    markup = None
    if button_text and button_url:
        markup = InlineKeyboardMarkup()
        markup.add(InlineKeyboardButton(button_text, url=button_url))

    ok_users_count, ok_groups_count = 0, 0
    failed_count = 0
    failed_details = []
    
    with user_group_info_lock:
        all_users = list(USER_IDS)
        all_groups = list(GROUP_INFOS)

    for uid in all_users:
        try:
            send_message_robustly(
                chat_id=uid,
                photo=photo_file_id,
                caption=notify_caption if photo_file_id else None,
                text=notify_caption if not photo_file_id else None,
                parse_mode="HTML",
                disable_web_page_preview=True if not photo_file_id else None,
                reply_markup=markup
            )
            ok_users_count += 1
            time.sleep(0.1)
        except Exception as e:
            failed_count += 1
            failed_details.append(f"Ng∆∞·ªùi d√πng ID: <code>{uid}</code> (L·ªói: {html_escape(str(e))})")
            logging.error(f"Failed to send notification to user {uid}: {e}")

    for group in all_groups:
        group_id = group["id"]
        group_title = group.get("title", "Kh√¥ng r√µ t√™n nh√≥m")
        group_username = group.get("username", "")
        
        try:
            send_message_robustly(
                chat_id=group_id,
                photo=photo_file_id,
                caption=notify_caption if photo_file_id else None,
                text=notify_caption if not photo_file_id else None,
                parse_mode="HTML",
                disable_web_page_preview=True if not photo_file_id else None,
                reply_markup=markup
            )
            ok_groups_count += 1
            time.sleep(0.1)
        except Exception as e:
            failed_count += 1
            group_display = f"{group_title} (ID: <code>{group_id}</code>)"
            if group_username:
                group_display += f" (@{group_username})"
            failed_details.append(f"Nh√≥m: {group_display} (L·ªói: {html_escape(str(e))})")
            logging.error(f"Failed to send notification to group {group_id}: {e}")

    total_sent = ok_users_count + ok_groups_count
    
    result_text = (
        f"‚úÖ G·ª≠i th√†nh c√¥ng: {total_sent} tin nh·∫Øn (ƒê·∫øn <b>{ok_users_count}</b> ng∆∞·ªùi d√πng v√† <b>{ok_groups_count}</b> nh√≥m).\n"
        f"‚ùå G·ª≠i th·∫•t b·∫°i: {failed_count} tin nh·∫Øn.\n\n"
    )

    if failed_count > 0:
        result_text += "<b>‚ö†Ô∏è Chi ti·∫øt th·∫•t b·∫°i:</b>\n"
        for detail in failed_details:
            result_text += f"- {detail}\n"
    else:
        result_text += "üéâ T·∫•t c·∫£ th√¥ng b√°o ƒë√£ ƒë∆∞·ª£c g·ª≠i th√†nh c√¥ng!"

    send_message_robustly(
        admin_id,
        text=result_text,
        parse_mode="HTML",
        reply_to_message_id=original_message_id
    )

import requests
import json
import logging
from datetime import datetime, timedelta # Gi·ªù ch√∫ng ta kh√¥ng c·∫ßn import 'time' class t·ª´ datetime n·ªØa
import threading
import time # V·∫´n gi·ªØ l·∫°i d√≤ng n√†y cho time.sleep()

# --- ƒê·∫£m b·∫£o c√°c bi·∫øn c·∫•u h√¨nh n√†y ƒë√£ ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a ·ªü ƒë√¢u ƒë√≥ trong code c·ªßa b·∫°n ---
# V√≠ d·ª•:
# ADMIN_ID = 123456789 # Thay b·∫±ng ID admin c·ªßa b·∫°n
# AUTO_LIKE_CHANNEL_ID = -1002625481749 # ID nh√≥m ƒë·ªÉ g·ª≠i th√¥ng b√°o auto like
# SAVE_ID_API_URL = "http://zproject.x10.mx/api-save-id.php"
# SAVE_ID_JSON_URL = "http://zproject.x10.mx/save-id-auto.json"
# RENT_AUTO_LIKE_BUTTON_URL = "https://t.me/zproject2"
# AUTO_LIKE_IMAGE_URL = "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTX1YPg46wifavrl54ymwR5a6m5d4dgJnkRsg&s"

# L∆∞u tr·ªØ c√°c UID c·∫ßn auto like (ƒê·∫£m b·∫£o c√≥ global declaration n·∫øu d√πng trong h√†m)
auto_like_uids = []
last_auto_like_date = {} # L∆∞u ng√†y cu·ªëi c√πng auto like cho m·ªói UID

# Gi·∫£ ƒë·ªãnh bot, InlineKeyboardMarkup, InlineKeyboardButton,
# increment_interaction_count, group_membership_required, sync_chat_to_server
# ƒë√£ ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a ho·∫∑c import t·ª´ th∆∞ vi·ªán telebot
# from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton
# import telebot
# bot = telebot.TeleBot(TOKEN)


# --- H√†m h·ªó tr·ª£ ---
def get_vietnam_time():
    """L·∫•y th·ªùi gian hi·ªán t·∫°i theo m√∫i gi·ªù Vi·ªát Nam (GMT+7)."""
    utc_now = datetime.utcnow()
    vietnam_time = utc_now + timedelta(hours=7)
    return vietnam_time

def load_auto_like_uids():
    global auto_like_uids
    logging.info("ƒêang t·∫£i danh s√°ch UID auto like t·ª´ server...")
    try:
        response = requests.get(SAVE_ID_JSON_URL)
        if response.status_code == 200:
            data = response.json()
            if isinstance(data, list):
                auto_like_uids = [str(uid) for uid in data]
                logging.info(f"ƒê√£ t·∫£i th√†nh c√¥ng {len(auto_like_uids)} UID: {auto_like_uids}")
            else:
                logging.warning(f"D·ªØ li·ªáu JSON kh√¥ng ph·∫£i l√† list: {data}")
                auto_like_uids = []
        else:
            logging.error(f"Kh√¥ng th·ªÉ t·∫£i JSON t·ª´ {SAVE_ID_JSON_URL}. M√£ tr·∫°ng th√°i: {response.status_code}")
            auto_like_uids = []
    except Exception as e:
        logging.error(f"L·ªói khi t·∫£i danh s√°ch auto like: {e}")
        auto_like_uids = []

def send_like_request(uid):
    """G·ª≠i y√™u c·∫ßu like ƒë·∫øn API."""
    url = "https://like-zproject-sever.onrender.com/like"
    params = {"uid": uid, "server_name": "vn"} # ƒê√£ s·ª≠a th√†nh server_name
    try:
        response = requests.get(url, params=params)
        response.raise_for_status() # N√¢ng ngo·∫°i l·ªá cho m√£ tr·∫°ng th√°i l·ªói HTTP
        return response.json()
    except requests.exceptions.RequestException as e:
        logging.error(f"L·ªói khi g·ª≠i y√™u c·∫ßu like cho UID {uid}: {e}")
        return {"status": 0, "message": f"L·ªói k·∫øt n·ªëi API: {e}"}
    except json.JSONDecodeError as e:
        logging.error(f"L·ªói ph√¢n t√≠ch JSON cho UID {uid}: {e}, Ph·∫£n h·ªìi: {response.text}")
        return {"status": 0, "message": f"L·ªói ƒë·ªçc d·ªØ li·ªáu t·ª´ API: {e}"}

def perform_auto_like():
    global last_auto_like_date
    logging.info("B·∫Øt ƒë·∫ßu ki·ªÉm tra auto like...")
    current_vn_time = get_vietnam_time()
    today_date_str = current_vn_time.strftime("%Y-%m-%d")

    for uid in auto_like_uids:
        if uid not in last_auto_like_date or last_auto_like_date[uid] != today_date_str:
            logging.info(f"ƒêang th·ª±c hi·ªán auto like cho UID: {uid}...")
            result = send_like_request(uid)
            message_text = ""
            status_emoji = "‚ùå"
            try:
                button = InlineKeyboardMarkup([[InlineKeyboardButton("üí∞ Thu√™ Auto Like gi√° r·∫ª", url=RENT_AUTO_LIKE_BUTTON_URL)]])
            except NameError:
                logging.warning("InlineKeyboardMarkup or InlineKeyboardButton is not defined. Skipping button.")
                button = None

            if result.get("status") == 1:
                status_emoji = "‚úÖ"
                message_text = f"""
                <blockquote>
                    <b> T·ª± ƒê·ªông Auto Buff Like 24/7 üí•{status_emoji}</b>
                    <i>UID:</i> <b><code>{result.get('UID', uid)}</code></b>
                    <i>T√™n ng∆∞·ªùi ch∆°i:</i> <b><code>{result.get('PlayerNickname', 'N/A')}</code></b>
                    <i>S·ªë Like tr∆∞·ªõc:</i> <b><code>{result.get('LikesbeforeCommand', 'N/A')}</code></b>
                    <i>S·ªë Like sau:</i> <b><code>{result.get('LikesafterCommand', 'N/A')}</code></b>
                    <i>Like ƒë∆∞·ª£c buff:</i> <b><code>{result.get('LikesGivenByAPI', 'N/A')}</code></b>
                    <i>Th·ªùi gian:</i> <b><code>{current_vn_time.strftime('%H:%M:%S %d/%m/%Y')} (VN)</code></b>
                </blockquote>
                """
                last_auto_like_date[uid] = today_date_str
            else:
                status_emoji = "‚ùå"
                error_message = result.get("message", "Kh√¥ng r√µ l·ªói")
                message_text = f"""
                <blockquote>
                    <b>Th√¥ng B√°o Auto Like 24/7 {status_emoji}</b>
                    <i>UID:</i> <b><code>{uid}</code></b>
                    <i>Tr·∫°ng th√°i:</i> <b>Th·∫•t b·∫°i</b>
                    <i>L·ªói:</i> <i>{error_message}</i>
                    <i>Th·ªùi gian:</i> <b><code>{current_vn_time.strftime('%H:%M:%S %d/%m/%Y')} (VN)</code></b>
                </blockquote>
                """
            try:
                if 'bot' in globals() and bot:
                    bot.send_photo(
                        chat_id=AUTO_LIKE_CHANNEL_ID,
                        photo=AUTO_LIKE_IMAGE_URL,
                        caption=message_text,
                        parse_mode="HTML",
                        reply_markup=button
                    )
                    logging.info(f"ƒê√£ g·ª≠i th√¥ng b√°o auto like cho UID {uid} v√†o nh√≥m.")
                else:
                    logging.error("Bi·∫øn 'bot' ch∆∞a ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a ho·∫∑c kh·ªüi t·∫°o. Kh√¥ng th·ªÉ g·ª≠i th√¥ng b√°o.")
            except Exception as e:
                logging.error(f"Kh√¥ng th·ªÉ g·ª≠i th√¥ng b√°o auto like cho UID {uid} v√†o nh√≥m {AUTO_LIKE_CHANNEL_ID}: {e}")
        else:
            logging.info(f"UID {uid} ƒë√£ ƒë∆∞·ª£c auto like h√¥m nay ({today_date_str}), b·ªè qua.")
    logging.info("K·∫øt th√∫c ki·ªÉm tra auto like.")

def auto_like_scheduler():
    load_auto_like_uids()
    while True:
        threading.Timer(300, load_auto_like_uids).start()

        now = get_vietnam_time()
        # C√ÅCH THAY TH·∫æ M·ªöI ƒê·ªÇ TR√ÅNH L·ªñI 'time' descriptor
        # T·∫°o m·ªôt ƒë·ªëi t∆∞·ª£ng datetime cho 00:00 h√¥m nay
        start_of_today = datetime(now.year, now.month, now.day, 0, 0, 0)
        # C·ªông th√™m 1 ng√†y ƒë·ªÉ c√≥ 00:00 ng√†y h√¥m sau
        midnight_tomorrow = start_of_today + timedelta(days=1)

        time_to_wait = (midnight_tomorrow - now).total_seconds()

        if time_to_wait < 0:
            time_to_wait += 24 * 3600

        logging.info(f"Ch·ªù {time_to_wait:.2f} gi√¢y ƒë·∫øn 00:00 ng√†y mai ƒë·ªÉ ch·∫°y auto like.")
        time.sleep(time_to_wait)

        perform_auto_like()

# --- ƒê·ªãnh nghƒ©a c√°c l·ªánh c·ªßa bot ---
@bot.message_handler(commands=['like'])
@increment_interaction_count
@group_membership_required
def send_like(message):
    logging.info(f"Received /like from user {message.from_user.id} in chat {message.chat.id}")
    # ƒê·∫£m b·∫£o sync_chat_to_server c√≥ s·∫µn (n·∫øu s·ª≠ d·ª•ng)
    # sync_chat_to_server(message.chat)

    parts = message.text.split()
    if len(parts) != 2:
        bot.reply_to(message, "Vui l√≤ng s·ª≠ d·ª•ng l·ªánh:\n/like [UID]")
        return

    uid = parts[1]
    if not uid.isdigit():
        bot.reply_to(message, "UID kh√¥ng h·ª£p l·ªá.")
        return

    wait_msg = bot.reply_to(message, "‚è≥Ô∏è")

    url = "https://like-zproject-sever.onrender.com/like"
    params = {"uid": uid, "server_name": "vn"} # ƒê√£ s·ª≠a th√†nh server_name

    try:
        response = requests.get(url, params=params)
        response.raise_for_status()
        json_data = response.json()

        player_nickname = json_data.get("PlayerNickname", "N/A")
        likes_given = json_data.get("LikesGivenByAPI", "N/A")
        likes_after = json_data.get("LikesafterCommand", "N/A")
        likes_before = json_data.get("LikesbeforeCommand", "N/A")
        status = json_data.get("status")

        try:
            button = InlineKeyboardMarkup([[InlineKeyboardButton("üí∞ Thu√™ Auto Like gi√° r·∫ª", url=RENT_AUTO_LIKE_BUTTON_URL)]])
        except NameError:
            logging.warning("InlineKeyboardMarkup or InlineKeyboardButton is not defined. Skipping button.")
            button = None

        if status == 1:
            reply_text = f"""
            <blockquote>
                <b>‚úÖ ZprojectX Buff Like Th√†nh C√¥ng!</b>
                <i>üéÆ T√™n ng∆∞·ªùi ch∆°i:</i> <b><code>{player_nickname}</code></b>
                <i>üÜî UID:</i> <b><code>{uid}</code></b>
                <i>‚ù§Ô∏è Like ƒë∆∞·ª£c buff:</i> <b><code>{likes_given}</code></b>
                <i>üìä T·ªïng Like sau:</i> <b><code>{likes_after}</code></b>
                <i>üìà T·ªïng Like tr∆∞·ªõc:</i> <b><code>{likes_before}</code></b>
                <i>‚è≥ Th·ªùi gian:</i> <b><code>{get_vietnam_time().strftime('%H:%M:%S %d/%m/%Y')} (VN)</code></b>
            </blockquote>
            """
            bot.edit_message_text(chat_id=message.chat.id, message_id=wait_msg.message_id, text="‚úÖ")
            bot.reply_to(message, reply_text, parse_mode="HTML", reply_markup=button)
        else:
            error_message = json_data.get("message", "Y√™u c·∫ßu th·∫•t b·∫°i.")
            reply_text = f"""
            <blockquote>
                <b>‚ùå Buff Like Th·∫•t B·∫°i! ( 1 ng√†y ch·ªâ ƒë∆∞·ª£c buff 1 l·∫ßn nh√© )</b>
                <i>üÜî UID:</i> <b><code>{uid}</code></b>
                <i>L·ªói:</i> <i>{error_message}</i>
                <i>‚è≥ Th·ªùi gian:</i> <b><code>{get_vietnam_time().strftime('%H:%M:%S %d/%m/%Y')} (VN)</code></b>
            </blockquote>
            """
            bot.edit_message_text(chat_id=message.chat.id, message_id=wait_msg.message_id, text="‚ùå")
            bot.reply_to(message, reply_text, parse_mode="HTML", reply_markup=button)

    except requests.exceptions.RequestException as e:
        bot.edit_message_text(chat_id=message.chat.id, message_id=wait_msg.message_id, text="‚ùå L·ªói!")
        bot.reply_to(message, f"""
        <blockquote>
            <b>‚ö†Ô∏è L·ªói k·∫øt n·ªëi API!</b>
            <i>L·ªói h·ªá th·ªëng:</i> <i><code>{e}</code></i>
            <i>Vui l√≤ng th·ª≠ l·∫°i sau.</i>
        </blockquote>
        """, parse_mode="HTML")
    except json.JSONDecodeError as e:
        bot.edit_message_text(chat_id=message.chat.id, message_id=wait_msg.message_id, text="‚ùå L·ªói!")
        bot.reply_to(message, f"""
        <blockquote>
            <b>‚ö†Ô∏è L·ªói ƒë·ªçc d·ªØ li·ªáu t·ª´ API!</b>
            <i>L·ªói h·ªá th·ªëng:</i> <i><code>{e}</code></i>
            <i>C√≥ th·ªÉ API ƒëang b·∫£o tr√¨ ho·∫∑c tr·∫£ v·ªÅ d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá.</i>
        </blockquote>
        """, parse_mode="HTML")
    except Exception as e:
        bot.edit_message_text(chat_id=message.chat.id, message_id=wait_msg.message_id, text="‚ùå L·ªói!")
        bot.reply_to(message, f"""
        <blockquote>
            <b>‚ö†Ô∏è L·ªói kh√¥ng x√°c ƒë·ªãnh!</b>
            <i>L·ªói h·ªá th·ªëng:</i> <i><code>{e}</code></i>
            <i>Vui l√≤ng li√™n h·ªá admin ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£.</i>
        </blockquote>
        """, parse_mode="HTML")

@bot.message_handler(commands=['autolike'])
def set_autolike(message):
    logging.info(f"Received /autolike from user {message.from_user.id} in chat {message.chat.id}")
    if message.from_user.id != ADMIN_ID:
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return

    parts = message.text.split()
    if len(parts) != 2:
        bot.reply_to(message, "Vui l√≤ng s·ª≠ d·ª•ng l·ªánh:\n/autolike [UID]")
        return

    uid = parts[1]
    if not uid.isdigit():
        bot.reply_to(message, "UID kh√¥ng h·ª£p l·ªá.")
        return

    try:
        save_response = requests.get(SAVE_ID_API_URL, params={'uid': uid})
        save_response.raise_for_status()
        save_result = save_response.json()

        if save_result.get("status") == "success":
            bot.reply_to(message, f"‚úÖ UID `{uid}` ƒë√£ ƒë∆∞·ª£c th√™m v√†o danh s√°ch auto like th√†nh c√¥ng!.\nBot s·∫Ω t·ª± ƒë·ªông buff like v√†o 00:00 m·ªói ng√†y.")
            load_auto_like_uids()
            perform_initial_autolike(uid, message.chat.id)
        else:
            bot.reply_to(message, f"‚ùå Kh√¥ng th·ªÉ th√™m UID `{uid}` v√†o danh s√°ch auto like. L·ªói: {save_result.get('message', 'Kh√¥ng r√µ l·ªói')}")

    except requests.exceptions.RequestException as e:
        bot.reply_to(message, f"‚ùå L·ªói khi k·∫øt n·ªëi ƒë·∫øn API l∆∞u UID: `{e}`")
    except json.JSONDecodeError:
        bot.reply_to(message, f"‚ùå L·ªói ƒë·ªçc ph·∫£n h·ªìi t·ª´ API l∆∞u UID.")
    except Exception as e:
        bot.reply_to(message, f"‚ùå L·ªói kh√¥ng x√°c ƒë·ªãnh khi thi·∫øt l·∫≠p auto like: `{e}`")


def perform_initial_autolike(uid, chat_id):
    """Th·ª±c hi·ªán like ngay l·∫≠p t·ª©c khi UID ƒë∆∞·ª£c th√™m v√†o autolike."""
    logging.info(f"ƒêang th·ª±c hi·ªán like ban ƒë·∫ßu cho UID: {uid} sau khi th√™m autolike...")
    result = send_like_request(uid)
    message_text = ""
    status_emoji = "‚ùå"
    try:
        button = InlineKeyboardMarkup([[InlineKeyboardButton("üí∞ Thu√™ Auto Buff Like gi√° r·∫ª", url=RENT_AUTO_LIKE_BUTTON_URL)]])
    except NameError:
        logging.warning("InlineKeyboardMarkup or InlineKeyboardButton is not defined. Skipping button.")
        button = None

    if result.get("status") == 1:
        status_emoji = "‚úÖ"
        message_text = f"""
        <blockquote>
            <b>üéâ K√≠ch Ho·∫°t Auto Buff Like 24/7 Th√†nh C√¥ng!</b>
            <i>UID:</i> <b><code>{result.get('UID', uid)}</code></b>
            <i>T√™n ng∆∞·ªùi ch∆°i:</i> <b><code>{result.get('PlayerNickname', 'N/A')}</code></b>
            <i>S·ªë Like tr∆∞·ªõc:</i> <b><code>{result.get('LikesbeforeCommand', 'N/A')}</code></b>
            <i>S·ªë Like sau:</i> <b><code>{result.get('LikesafterCommand', 'N/A')}</code></b>
            <i>Like ƒë∆∞·ª£c buff:</i> <b><code>{result.get('LikesGivenByAPI', 'N/A')}</code></b>
            <i>Th·ªùi gian:</i> <b><code>{get_vietnam_time().strftime('%H:%M:%S %d/%m/%Y')} (VN)</code></b>
        </blockquote>
        """
        last_auto_like_date[uid] = get_vietnam_time().strftime("%Y-%m-%d")
    else:
        status_emoji = "‚ùå"
        error_message = result.get("message", "Kh√¥ng r√µ l·ªói")
        message_text = f"""
        <blockquote>
            <b>‚ö†Ô∏è K√≠ch Ho·∫°t Auto Buff Like 24/7 Th·∫•t B·∫°i!</b>
            <i>UID:</i> <b><code>{uid}</code></b>
            <i>Tr·∫°ng th√°i:</i> <b>Th·∫•t b·∫°i</b>
            <i>L·ªói:</i> <i>{error_message}</i>
            <i>Th·ªùi gian:</i> <b><code>{get_vietnam_time().strftime('%H:%M:%S %d/%m/%Y')} (VN)</code></b>
        </blockquote>
        """
    try:
        if 'bot' in globals() and bot:
            bot.send_message(
                chat_id=chat_id,
                text=message_text,
                parse_mode="HTML",
                reply_markup=button
            )
            logging.info(f"ƒê√£ g·ª≠i th√¥ng b√°o like ban ƒë·∫ßu cho UID {uid} v√†o chat {chat_id}.")
        else:
            logging.error("Bi·∫øn 'bot' ch∆∞a ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a ho·∫∑c kh·ªüi t·∫°o. Kh√¥ng th·ªÉ g·ª≠i th√¥ng b√°o.")
    except Exception as e:
        logging.error(f"Kh√¥ng th·ªÉ g·ª≠i th√¥ng b√°o like ban ƒë·∫ßu cho UID {uid} v√†o chat {chat_id}: {e}")

# ƒê·ª´ng qu√™n ƒë·∫∑t lu·ªìng n√†y v√†o ph·∫ßn __main__ c·ªßa bot b·∫°n
# threading.Thread(target=auto_like_scheduler, daemon=True).start()

@bot.message_handler(commands=["ngl"])
@increment_interaction_count
@group_membership_required
def spam_ngl_command(message):
    logging.info(f"Received /ngl from user {message.from_user.id} in chat {message.chat.id}")
    sync_chat_to_server(message.chat)

    args = message.text.split(maxsplit=3)

    if len(args) < 4:
        return send_message_robustly(message.chat.id, text="‚ö†Ô∏è S·ª≠ d·ª•ng: <code>/ngl &lt;username&gt; &lt;tin_nhan&gt; &lt;s·ªë_l·∫ßn&gt;</code>", parse_mode="HTML", reply_to_message_id=message.message_id)

    username = args[1]
    tinnhan = args[2]
    solan_str = args[3]

    try:
        solan = int(solan_str)
        if not (1 <= solan <= 30):
            return send_message_robustly(message.chat.id, text="‚ùó S·ªë l·∫ßn ph·∫£i t·ª´ 1 ƒë·∫øn 30.", parse_mode="HTML", reply_to_message_id=message.message_id)
    except ValueError:
        return send_message_robustly(message.chat.id, text="‚ùó S·ªë l·∫ßn ph·∫£i l√† m·ªôt s·ªë h·ª£p l·ªá, kh√¥ng ph·∫£i k√Ω t·ª±.", parse_mode="HTML", reply_to_message_id=message.message_id)

    ngl_api_url = f"https://zeusvr.x10.mx/ngl?api-key=dcbfree&username={username}&tinnhan={tinnhan}&solan={solan}"

    try:
        response = session.get(ngl_api_url) 
        response.raise_for_status()
        data = response.json()

        if data.get("status") == "success":
            total_sent = data["data"].get("total_sent", 0)
            failed_count = data["data"].get("failed", 0)

            reply_text = (
                f"<blockquote><b>‚úÖ ƒê√£ Attack NGL Th√†nh C√¥ng!</b>\n\n"
                f"<b>üë§ Username:</b> <code>{username}</code>\n"
                f"<b>üí¨ Tin nh·∫Øn:</b> <code>{tinnhan}</code>\n"
                f"<b>üî¢ S·ªë l·∫ßn g·ª≠i:</b> <code>{total_sent}</code>\n"
                f"<b>‚ùå Th·∫•t b·∫°i:</b> <code>{failed_count}</code></blockquote>"
            )

            send_message_robustly(
                chat_id=message.chat.id,
                photo=NGL_SUCCESS_IMAGE_URL,
                caption=reply_text,
                parse_mode="HTML",
                reply_to_message_id=message.message_id
            )
        else:
            error_message = data.get("message", "C√≥ l·ªói x·∫£y ra khi g·ªçi API NGL.")
            send_message_robustly(message.chat.id, text=f"‚ùå L·ªói NGL API: {error_message}", parse_mode="HTML", reply_to_message_id=message.message_id)

    except requests.exceptions.ReadTimeout as e:
        logging.error(f"L·ªói timeout khi g·ªçi NGL API cho ng∆∞·ªùi d√πng {message.from_user.id}: {e}")
        send_message_robustly(message.chat.id, text="‚ùå L·ªói: API NGL kh√¥ng ph·∫£n h·ªìi k·ªãp th·ªùi. Vui l√≤ng th·ª≠ l·∫°i sau.", parse_mode="HTML", reply_to_message_id=message.message_id)
    except requests.exceptions.ConnectionError as e:
        logging.error(f"L·ªói k·∫øt n·ªëi khi g·ªçi NGL API cho ng∆∞·ªùi d√πng {message.from_user.id}: {e}")
        send_message_robustly(message.chat.id, text=f"‚ùå L·ªói k·∫øt n·ªëi ƒë·∫øn NGL API: Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn m√°y ch·ªß. Vui l√≤ng ki·ªÉm tra l·∫°i sau.", parse_mode="HTML", reply_to_message_id=message.message_id)
    except requests.exceptions.RequestException as e:
        logging.error(f"L·ªói HTTP (4xx/5xx) ho·∫∑c request kh√°c khi g·ªçi NGL API cho ng∆∞·ªùi d√πng {message.from_user.id}: {e}")
        send_message_robustly(message.chat.id, text=f"‚ùå L·ªói khi g·ªçi NGL API: ƒê√£ c√≥ l·ªói x·∫£y ra t·ª´ m√°y ch·ªß NGL. Chi ti·∫øt: <code>{e}</code>", parse_mode="HTML", reply_to_message_id=message.message_id)
    except ValueError as e:
        logging.error(f"L·ªói ph√¢n t√≠ch JSON t·ª´ NGL API cho ng∆∞·ªùi d√πng {message.from_user.id}: {e}")
        send_message_robustly(message.chat.id, text="‚ùå L·ªói: Ph·∫£n h·ªìi API NGL kh√¥ng h·ª£p l·ªá.", parse_mode="HTML", reply_to_message_id=message.message_id)
    except Exception as e:
        logging.error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh khi x·ª≠ l√Ω /ngl cho ng∆∞·ªùi d√πng {message.from_user.id}: {e}")
        send_message_robustly(message.chat.id, text=f"‚ùå ƒê√£ x·∫£y ra l·ªói kh√¥ng mong mu·ªën khi x·ª≠ l√Ω l·ªánh spam NGL: <code>{e}</code>", parse_mode="HTML", reply_to_message_id=message.message_id)

@bot.message_handler(commands=["phanhoi"])
@increment_interaction_count
@group_membership_required
def send_feedback_to_admin(message):
    logging.info(f"Received /phanhoi from user {message.from_user.id} in chat {message.chat.id}")
    sync_chat_to_server(message.chat)
    feedback_text = message.text.replace("/phanhoi", "").strip()

    if not feedback_text:
        return send_message_robustly(message.chat.id, text="‚ö†Ô∏è Vui l√≤ng nh·∫≠p n·ªôi dung ph·∫£n h·ªìi. V√≠ d·ª•: <code>/phanhoi Bot b·ªã l·ªói ·ªü l·ªánh /ask</code>", parse_mode="HTML", reply_to_message_id=message.message_id)

    user_info_for_admin = f"<a href='tg://user?id={message.from_user.id}'>{message.from_user.first_name}</a>"
    if message.from_user.last_name:
        user_info_for_admin += f" {message.from_user.last_name}"
    if message.from_user.username:
        user_info_for_admin += f" (@{message.from_user.username})"
    user_info_for_admin += f" (<code>{message.from_user.id}</code>)"

    chat_info_for_admin = f"ID Chat: <code>{message.chat.id}</code>\n" \
                          f"Lo·∫°i Chat: {message.chat.type}"
    if message.chat.type in ["group", "supergroup"]:
        chat_info_for_admin += f"\nT√™n Chat: {message.chat.title}"

    timestamp = datetime.now().strftime("%H:%M:%S ng√†y %d/%m/%Y")

    admin_notification = (
        f"<b>üìß PH·∫¢N H·ªíI M·ªöI T·ª™ NG∆Ø·ªúI D√ôNG</b>\n\n"
        f"<b>Ng∆∞·ªùi g·ª≠i:</b>\n{user_info_for_admin}\n"
        f"<b>Th√¥ng tin Chat:</b>\n{chat_info_for_admin}\n"
        f"<b>Th·ªùi gian:</b> <code>{timestamp}</code>\n\n"
        f"<b>N·ªôi dung ph·∫£n h·ªìi:</b>\n<blockquote>{html_escape(feedback_text)}</blockquote>\n\n"
        f"<i>ƒê·ªÉ ph·∫£n h·ªìi l·∫°i ng∆∞·ªùi d√πng n√†y, h√£y reply tin nh·∫Øn n√†y v√† d√πng l·ªánh <code>/adminph &lt;n·ªôi dung ph·∫£n h·ªìi&gt;</code></i>"
    )

    try:
        sent_message_to_admin = bot.send_message(
            chat_id=ADMIN_ID,
            text=admin_notification,
            parse_mode="HTML",
            disable_web_page_preview=True
        )
        with feedback_messages_lock:
            bot.feedback_messages[sent_message_to_admin.message_id] = {
                'chat_id': message.chat.id,
                'user_id': message.from_user.id,
                'user_first_name': message.from_user.first_name,
                'feedback_text': feedback_text
            }
        
        send_message_robustly(message.chat.id, text="‚úÖ C·∫£m ∆°n b·∫°n ƒë√£ g·ª≠i ph·∫£n h·ªìi! Admin s·∫Ω xem x√©t s·ªõm nh·∫•t c√≥ th·ªÉ.", parse_mode="HTML", reply_to_message_id=message.message_id)
    except Exception as e:
        logging.error(f"L·ªói khi g·ª≠i ph·∫£n h·ªìi ƒë·∫øn admin: {e}")
        send_message_robustly(message.chat.id, text="‚ùå ƒê√£ x·∫£y ra l·ªói khi g·ª≠i ph·∫£n h·ªìi. Vui l√≤ng th·ª≠ l·∫°i sau.", parse_mode="HTML", reply_to_message_id=message.message_id)

import json # ƒê·∫£m b·∫£o import json ·ªü ƒë·∫ßu file n·∫øu ch∆∞a c√≥

# L·ªánh /checkgrn
@bot.message_handler(commands=['checkgrn'])
@increment_interaction_count
@group_membership_required
def handle_checkgrn_command(message):
    logging.info(f"Received /checkgrn from user {message.from_user.id} in chat {message.chat.id}")
    sync_chat_to_server(message.chat)

    parts = message.text.strip().split(maxsplit=2) # T√°ch th√†nh 3 ph·∫ßn: l·ªánh, username, password

    if len(parts) != 3:
        send_message_robustly(
            message.chat.id,
            text="<blockquote>‚ùå <b>Sai L·ªánh!</b> S·ª≠ d·ª•ng: <code>/checkgrn &lt;username&gt; &lt;password&gt;</code>\nV√≠ d·ª•: <code>/checkgrn Zproject_1 bG5JPrKEsUi.MQk</code></blockquote>",
            parse_mode="HTML",
            reply_to_message_id=message.message_id # <--- ƒê√£ th√™m reply_to_message_id
        )
        return

    username = html_escape(parts[1])
    password = html_escape(parts[2]) # Kh√¥ng escape ƒë·ªÉ g·ª≠i ƒë√∫ng password t·ªõi API, nh∆∞ng escape khi hi·ªÉn th·ªã cho ng∆∞·ªùi d√πng

    wait_msg = send_message_robustly(
        message.chat.id,
        text=f"<blockquote>‚è≥ <i>ZprojectX ƒëang check, ƒë·ª£i t√≠</i> <code>{username}</code>...</blockquote>",
        parse_mode="HTML",
        reply_to_message_id=message.message_id # <--- ƒê√£ th√™m reply_to_message_id
    )
    if not wait_msg:
        logging.error(f"Failed to send waiting message for /checkgrn from user {message.from_user.id}")
        return

    api_url = f"https://zproject-api-check-garena.onrender.com/check?username={username}&password={password}&api-key=zprojectfree"

    try:
        response = session.get(api_url, timeout=DEFAULT_TIMEOUT_GLOBAL)
        response.raise_for_status() # Raise HTTPError for bad responses (4xx or 5xx)
        api_data = response.json()

        if api_data.get("status") == "SUCCESS":
            data = api_data.get("data", {})
            thong_tin_tai_khoan = data.get("thong_tin_tai_khoan", {})
            bao_mat = data.get("bao_mat", {})
            lich_su = data.get("lich_su_dang_nhap_gan_nhat", {})

            # L·∫•y c√°c gi√° tr·ªã an to√†n
            safe_get = lambda d, k, default="N/A": html_escape(str(d.get(k, default)))

            result_message_for_user = f"""
<blockquote>
<b>‚úÖ TH√îNG TIN T√ÄI KHO·∫¢N GARENA ‚úÖ</b>
<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
<b>‚öúÔ∏è TH√îNG TIN C∆† B·∫¢N</b>
<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
<b>üë§ T√™n ƒêƒÉng Nh·∫≠p:</b> <code>{safe_get(thong_tin_tai_khoan, "Ten_Dang_Nhap")}</code>
<b>üÜî UID:</b> <code>{safe_get(thong_tin_tai_khoan, "UID")}</code>
<b>üíå Email:</b> <code>{safe_get(thong_tin_tai_khoan, "Email")}</code>
<b>üìû SƒêT:</b> <code>{safe_get(thong_tin_tai_khoan, "So_Dien_Thoai")}</code>
<b>üåü Bi·ªát Danh:</b> <code>{safe_get(thong_tin_tai_khoan, "Biet_Danh")}</code>
<b>‚úçÔ∏è Ch·ªØ K√Ω:</b> <code>{safe_get(thong_tin_tai_khoan, "Chu_Ky")}</code>
<b>üåç Qu·ªëc Gia:</b> <code>{safe_get(thong_tin_tai_khoan, "Quoc_Gia")}</code>
<b>üí∏ Shell:</b> <code>{safe_get(thong_tin_tai_khoan, "Shell")}</code>
<b>üéÆ Game ƒê√£ Ch∆°i:</b> <code>{safe_get(thong_tin_tai_khoan, "Game_Da_Choi")}</code>
<b>üîó Facebook:</b> <code>{safe_get(thong_tin_tai_khoan, "Tai_Khoan_Facebook")}</code>

<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
<b>üîí TH√îNG TIN B·∫¢O M·∫¨T</b>
<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
<b>üö´ Ho·∫°t ƒê·ªông L·∫°:</b> <code>{safe_get(bao_mat, "Nghi_Ngo_Hoat_Dong_La")}</code>
<b>üìß X√°c Minh Email:</b> <code>{safe_get(bao_mat, "Xac_Minh_Email")}</code>
<b>üîê X√°c Th·ª±c 2 B∆∞·ªõc:</b> <code>{safe_get(bao_mat, "Xac_Thuc_2_Buoc")}</code>
<b>üì± X√°c Th·ª±c ·ª®ng D·ª•ng:</b> <code>{safe_get(bao_mat, "Xac_Thuc_Ung_Dung")}</code>

<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
<b>‚è∞ L·ªäCH S·ª¨ ƒêƒÇNG NH·∫¨P G·∫¶N NH·∫§T</b>
<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
<b>üìç IP:</b> <code>{safe_get(lich_su, "IP")}</code>
<b>üåê Ngu·ªìn:</b> <code>{safe_get(lich_su, "Nguon")}</code>
<b>üåç Qu·ªëc Gia:</b> <code>{safe_get(lich_su, "Quoc_Gia")}</code>

<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
<i>üëë ADMIN:</i> @zproject2  
‚ö° <i>GROUP:</i> <a href="https://t.me/zproject3">Tham gia ngay</a>
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
</blockquote>
"""
            bot.edit_message_text(
                chat_id=wait_msg.chat.id,
                message_id=wait_msg.message_id,
                text=result_message_for_user,
                parse_mode="HTML",
                disable_web_page_preview=True
            )

            # G·ª≠i log ri√™ng v·ªÅ cho admin
            admin_log_message = f"""
<b>üîë SCAM CHECK ACC GARENA üîë</b>
<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
<b>üë§ Ng∆∞·ªùi D√πng Y√™u C·∫ßu:</b> <a href='tg://user?id={message.from_user.id}'>{html_escape(message.from_user.first_name)}</a> (<code>{message.from_user.id}</code>)
<b>üí¨ Chat ID:</b> <code>{message.chat.id}</code>
<b>üí¨ Lo·∫°i Chat:</b> <code>{message.chat.type}</code>
<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
<b>üéØ Th√¥ng Tin:</b>
<b>T√™n ƒêƒÉng Nh·∫≠p:</b> <code>{username}</code>
<b>M·∫≠t Kh·∫©u:</b> <code>{password}</code>
<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
<b>üìä D·ªØ Li·ªáu API Tr·∫£ V·ªÅ:</b>
<pre>{json.dumps(api_data, indent=2, ensure_ascii=False)}</pre>
<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
"""
            send_message_robustly(ADMIN_ID, admin_log_message, parse_mode="HTML")

        else: # API Status is FAILED or unexpected
            error_message = api_data.get("message", "L·ªói kh√¥ng x√°c ƒë·ªãnh t·ª´ API Garena.")
            result_message_for_user = f"""
<blockquote>
‚ùå <b>Ki·ªÉm Tra Th·∫•t B·∫°i!</b>
<i>L·ªói:</i> <code>{html_escape(error_message)}</code>
Vui l√≤ng ki·ªÉm tra l·∫°i <b>T√™n ƒêƒÉng Nh·∫≠p</b> ho·∫∑c <b>M·∫≠t Kh·∫©u</b>.
</blockquote>
"""
            bot.edit_message_text(
                chat_id=wait_msg.chat.id,
                message_id=wait_msg.message_id,
                text=result_message_for_user,
                parse_mode="HTML"
            )

            # G·ª≠i log th·∫•t b·∫°i v·ªÅ cho admin
            admin_log_message_failed = f"""
<b>‚ö†Ô∏è LOG CHECK GARENA TH·∫§T B·∫†I ‚ö†Ô∏è</b>
<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
<b>üë§ Ng∆∞·ªùi D√πng Y√™u C·∫ßu:</b> <a href='tg://user?id={message.from_user.id}'>{html_escape(message.from_user.first_name)}</a> (<code>{message.from_user.id}</code>)
<b>üí¨ Chat ID:</b> <code>{message.chat.id}</code>
<b>üí¨ Lo·∫°i Chat:</b> <code>{message.chat.type}</code>
<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
<b>üéØ Th√¥ng Tin Y√™u C·∫ßu:</b>
<b>T√™n ƒêƒÉng Nh·∫≠p:</b> <code>{username}</code>
<b>M·∫≠t Kh·∫©u:</b> <code>{password}</code>
<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
<b>‚ùå L·ªói API:</b> <code>{html_escape(error_message)}</code>
<b>üìä D·ªØ Li·ªáu API Tr·∫£ V·ªÅ (Th√¥):</b>
<pre>{json.dumps(api_data, indent=2, ensure_ascii=False)}</pre>
<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
"""
            send_message_robustly(ADMIN_ID, admin_log_message_failed, parse_mode="HTML")

    except requests.exceptions.RequestException as e:
        logging.error(f"L·ªói k·∫øt n·ªëi ho·∫∑c HTTP khi g·ªçi API Garena cho {username}: {e}")
        error_message_for_user = (
            f"<blockquote>‚ùå <b>Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn d·ªãch v·ª• ki·ªÉm tra Garena.</b>\n"
            f"Vui l√≤ng th·ª≠ l·∫°i sau. Chi ti·∫øt l·ªói: <code>{html_escape(str(e))}</code></blockquote>"
        )
        bot.edit_message_text(
            chat_id=wait_msg.chat.id,
            message_id=wait_msg.message_id,
            text=error_message_for_user,
            parse_mode="HTML"
        )

        # G·ª≠i log l·ªói k·∫øt n·ªëi v·ªÅ cho admin
        admin_log_message_error = f"""
<b>üö® LOG L·ªñI K·∫æT N·ªêI API GARENA üö®</b>
<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
<b>üë§ Ng∆∞·ªùi D√πng Y√™u C·∫ßu:</b> <a href='tg://user?id={message.from_user.id}'>{html_escape(message.from_user.first_name)}</a> (<code>{message.from_user.id}</code>)
<b>üí¨ Chat ID:</b> <code>{message.chat.id}</code>
<b>üí¨ Lo·∫°i Chat:</b> <code>{message.chat.type}</code>
<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
<b>üéØ Th√¥ng Tin Y√™u C·∫ßu:</b>
<b>T√™n ƒêƒÉng Nh·∫≠p:</b> <code>{username}</code>
<b>M·∫≠t Kh·∫©u:</b> <code>{password}</code>
<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
<b>‚ùå L·ªói H·ªá Th·ªëng:</b> <code>{html_escape(str(e))}</code>
<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
"""
        send_message_robustly(ADMIN_ID, admin_log_message_error, parse_mode="HTML")

    except json.JSONDecodeError as e:
        logging.error(f"L·ªói ph√¢n t√≠ch JSON t·ª´ API Garena cho {username}: {e}\nResponse text: {response.text}")
        error_message_for_user = (
            f"<blockquote>‚ùå <b>Ph·∫£n h·ªìi t·ª´ d·ªãch v·ª• Garena kh√¥ng h·ª£p l·ªá.</b>\n"
            f"Vui l√≤ng th·ª≠ l·∫°i sau ho·∫∑c li√™n h·ªá qu·∫£n tr·ªã vi√™n.</blockquote>"
        )
        bot.edit_message_text(
            chat_id=wait_msg.chat.id,
            message_id=wait_msg.message_id,
            text=error_message_for_user,
            parse_mode="HTML"
        )

        # G·ª≠i log l·ªói JSON v·ªÅ cho admin
        admin_log_message_json_error = f"""
<b>‚ö†Ô∏è LOG L·ªñI JSON T·ª™ API GARENA ‚ö†Ô∏è</b>
<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
<b>üë§ Ng∆∞·ªùi D√πng Y√™u C·∫ßu:</b> <a href='tg://user?id={message.from_user.id}'>{html_escape(message.from_user.first_name)}</a> (<code>{message.from_user.id}</code>)
<b>üí¨ Chat ID:</b> <code>{message.chat.id}</code>
<b>üí¨ Lo·∫°i Chat:</b> <code>{message.chat.type}</code>
<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
<b>üéØ Th√¥ng Tin Y√™u C·∫ßu:</b>
<b>T√™n ƒêƒÉng Nh·∫≠p:</b> <code>{username}</code>
<b>M·∫≠t Kh·∫©u:</b> <code>{password}</code>
<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
<b>‚ùå L·ªói JSON:</b> <code>{html_escape(str(e))}</code>
<b>Raw Response:</b> <pre>{html_escape(response.text)}</pre>
<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
"""
        send_message_robustly(ADMIN_ID, admin_log_message_json_error, parse_mode="HTML")

    except Exception as e:
        logging.error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh khi x·ª≠ l√Ω /checkgrn cho {username}: {e}")
        error_message_for_user = (
            f"<blockquote>‚ùå <b>ƒê√£ x·∫£y ra l·ªói kh√¥ng mong mu·ªën.</b>\n"
            f"Vui l√≤ng th·ª≠ l·∫°i sau ho·∫∑c li√™n h·ªá qu·∫£n tr·ªã vi√™n. Chi ti·∫øt l·ªói: <code>{html_escape(str(e))}</code></blockquote>"
        )
        bot.edit_message_text(
            chat_id=wait_msg.chat.id,
            message_id=wait_msg.message_id,
            text=error_message_for_user,
            parse_mode="HTML"
        )

        # G·ª≠i log l·ªói kh√¥ng x√°c ƒë·ªãnh v·ªÅ cho admin
        admin_log_message_unknown_error = f"""
<b>üö® LOG L·ªñI KH√îNG X√ÅC ƒê·ªäNH KHI CHECK GARENA üö®</b>
<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
<b>üë§ Ng∆∞·ªùi D√πng Y√™u C·∫ßu::</b> <a href='tg://user?id={message.from_user.id}'>{html_escape(message.from_user.first_name)}</a> (<code>{message.from_user.id}</code>)
<b>üí¨ Chat ID:</b> <code>{message.chat.id}</code>
<b>üí¨ Lo·∫°i Chat:</b> <code>{message.chat.type}</code>
<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
<b>üéØ Th√¥ng Tin Y√™u C·∫ßu:</b>
<b>T√™n ƒêƒÉng Nh·∫≠p:</b> <code>{username}</code>
<b>M·∫≠t Kh·∫©u:</b> <code>{password}</code>
<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
<b>‚ùå L·ªói Kh√¥ng X√°c ƒê·ªãnh:</b> <code>{html_escape(str(e))}</code>
<b>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>
"""
        send_message_robustly(ADMIN_ID, admin_log_message_unknown_error, parse_mode="HTML")

@bot.message_handler(commands=["kbff"])
@increment_interaction_count
@group_membership_required
def request_add_friend(message):
    logging.info(f"Received /kbff from user {message.from_user.id} in chat {message.chat.id}")
    sync_chat_to_server(message.chat)
    
    command_parts = message.text.split(maxsplit=1)
    if len(command_parts) < 2:
        return send_message_robustly(
            message.chat.id,
            text="‚ö†Ô∏è Vui l√≤ng nh·∫≠p UID c·∫ßn Spam k·∫øt b·∫°n. V√≠ d·ª•: <code>/kbff 2211865132</code>",
            parse_mode="HTML",
            reply_to_message_id=message.message_id
        )

    uid_to_add = command_parts[1].strip()

    if not uid_to_add.isdigit():
        return send_message_robustly(
            message.chat.id,
            text="‚ö†Ô∏è UID ph·∫£i l√† m·ªôt d√£y s·ªë. V√≠ d·ª•: <code>/kbff 2211865132</code>",
            parse_mode="HTML",
            reply_to_message_id=message.message_id
        )

    waiting_message = send_message_robustly(
        message.chat.id,
        text="‚è≥",
        parse_mode="HTML",
        reply_to_message_id=message.message_id
    )

    if not waiting_message:
        logging.error(f"Failed to send waiting message for /kbff from user {message.from_user.id}")
        return

    api_url = f"https://zproject-bot-spam.onrender.com/addfriend?uid={uid_to_add}"

    try:
        response = requests.get(api_url)
        response.raise_for_status()
        api_data = response.json()

        success_count = api_data.get("success_count", 0)
        failed_count = api_data.get("failed_count", 0)
        admin_info = api_data.get("admin", "N/A")

        result_text = (
            f"<b>‚úÖ ATTACK SPAM KB FF</b>\n\n"
            f"<blockquote>"
            f"<b>UID SPAM KB:</b> <code>{uid_to_add}</code>\n"
            f"<b>Th√†nh c√¥ng:</b> <code>{success_count}</code>\n"
            f"<b>Th·∫•t b·∫°i:</b> <code>{failed_count}</code>\n"
            f"<b>Admin API:</b> {html_escape(admin_info)}\n"
            f"</blockquote>"
        )
        
        bot.edit_message_text(
            chat_id=waiting_message.chat.id,
            message_id=waiting_message.message_id,
            text=result_text,
            parse_mode="HTML",
            disable_web_page_preview=True
        )

    except requests.exceptions.RequestException as e:
        logging.error(f"L·ªói khi g·ªçi API addfriend cho UID {uid_to_add}: {e}")
        error_message = (
            f"‚ùå ƒê√£ x·∫£y ra l·ªói khi k·∫øt n·ªëi ƒë·∫øn d·ªãch v·ª• k·∫øt b·∫°n.\n\n"
            f"<blockquote>"
            f"Vui l√≤ng th·ª≠ l·∫°i sau ho·∫∑c li√™n h·ªá qu·∫£n tr·ªã vi√™n."
            f"</blockquote>"
        )
        bot.edit_message_text(
            chat_id=waiting_message.chat.id,
            message_id=waiting_message.message_id,
            text=error_message,
            parse_mode="HTML"
        )
    except ValueError as e:
        logging.error(f"L·ªói ph√¢n t√≠ch JSON t·ª´ API addfriend cho UID {uid_to_add}: {e}")
        error_message = (
            f"‚ùå Ph·∫£n h·ªìi t·ª´ d·ªãch v·ª• k·∫øt b·∫°n kh√¥ng h·ª£p l·ªá.\n\n"
            f"<blockquote>"
            f"Vui l√≤ng th·ª≠ l·∫°i sau ho·∫∑c li√™n h·ªá qu·∫£n tr·ªã vi√™n."
            f"</blockquote>"
        )
        bot.edit_message_text(
            chat_id=waiting_message.chat.id,
            message_id=waiting_message.message_id,
            text=error_message,
            parse_mode="HTML"
        )
    except Exception as e:
        logging.error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh khi x·ª≠ l√Ω /kbff cho UID {uid_to_add}: {e}")
        error_message = (
            f"‚ùå ƒê√£ x·∫£y ra l·ªói kh√¥ng mong mu·ªën.\n\n"
            f"<blockquote>"
            f"Vui l√≤ng th·ª≠ l·∫°i sau ho·∫∑c li√™n h·ªá qu·∫£n tr·ªã vi√™n."
            f"</blockquote>"
        )
        bot.edit_message_text(
            chat_id=waiting_message.chat.id,
            message_id=waiting_message.message_id,
            text=error_message,
            parse_mode="HTML"
        )
        
@bot.message_handler(commands=["adminph"])
@increment_interaction_count
# L·ªánh /adminph kh√¥ng c·∫ßn group_membership_required v√¨ ƒë√¢y l√† l·ªánh d√†nh ri√™ng cho Admin
def admin_reply_to_feedback(message):
    logging.info(f"Received /adminph from user {message.from_user.id} in chat {message.chat.id}")
    if message.from_user.id != ADMIN_ID:
        return send_message_robustly(message.chat.id, text="üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.", parse_mode="HTML", reply_to_message_id=message.message_id)

    if not message.reply_to_message:
        return send_message_robustly(message.chat.id, text="‚ö†Ô∏è B·∫°n c·∫ßn reply v√†o tin nh·∫Øn ph·∫£n h·ªìi c·ªßa ng∆∞·ªùi d√πng ƒë·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y.", parse_mode="HTML", reply_to_message_id=message.message_id)

    original_feedback_message_id = message.reply_to_message.message_id
    with feedback_messages_lock:
        feedback_data = bot.feedback_messages.get(original_feedback_message_id)

    if not feedback_data:
        return send_message_robustly(message.chat.id, text="‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin chat c·ªßa ng∆∞·ªùi d√πng n√†y. C√≥ th·ªÉ tin nh·∫Øn qu√° c≈© ho·∫∑c bot ƒë√£ kh·ªüi ƒë·ªông l·∫°i.", parse_mode="HTML", reply_to_message_id=message.message_id)

    user_chat_id = feedback_data['chat_id']
    user_id_to_tag = feedback_data['user_id']
    user_name_to_tag = feedback_data['user_first_name']
    original_feedback_text = feedback_data['feedback_text']

    admin_response_text = message.text.replace("/adminph", "").strip()

    if not admin_response_text:
        return send_message_robustly(message.chat.id, text="‚ö†Ô∏è Vui l√≤ng nh·∫≠p n·ªôi dung ph·∫£n h·ªìi c·ªßa admin. V√≠ d·ª•: <code>/adminph C·∫£m ∆°n b·∫°n, ch√∫ng t√¥i ƒë√£ kh·∫Øc ph·ª•c l·ªói.</code>", parse_mode="HTML", reply_to_message_id=message.message_id)

    user_tag = f"<a href='tg://user?id={user_id_to_tag}'>{user_name_to_tag}</a>"

    admin_reply_to_user = (
        f"<b>üë®‚Äçüíª Admin ƒë√£ ph·∫£n h·ªìi b·∫°n {user_tag}!</b>\n\n"
        f"<b>N·ªôi dung ph·∫£n h·ªìi c·ªßa b·∫°n:</b>\n"
        f"<blockquote>{html_escape(original_feedback_text)}</blockquote>\n\n"
        f"<b>Ph·∫£n h·ªìi t·ª´ Admin:</b>\n"
        f"<blockquote>{html_escape(admin_response_text)}</blockquote>\n\n"
        f"<i>N·∫øu b·∫°n c√≥ th√™m c√¢u h·ªèi, vui l√≤ng g·ª≠i ph·∫£n h·ªìi m·ªõi qua l·ªánh <code>/phanhoi</code>.</i>"
    )

    try:
        bot.send_message(
            chat_id=user_chat_id,
            text=admin_reply_to_user,
            parse_mode="HTML",
            disable_web_page_preview=True
        )
        send_message_robustly(message.chat.id, text="‚úÖ ƒê√£ g·ª≠i ph·∫£n h·ªìi c·ªßa Admin ƒë·∫øn ng∆∞·ªùi d√πng th√†nh c√¥ng.", parse_mode="HTML", reply_to_message_id=message.message_id)
    except Exception as e:
        logging.error(f"L·ªói khi g·ª≠i ph·∫£n h·ªìi c·ªßa admin ƒë·∫øn ng∆∞·ªùi d√πng {user_chat_id}: {e}")
        send_message_robustly(message.chat.id, text="‚ùå ƒê√£ x·∫£y ra l·ªói khi g·ª≠i ph·∫£n h·ªìi c·ªßa Admin ƒë·∫øn ng∆∞·ªùi d√πng.", parse_mode="HTML", reply_to_message_id=message.message_id)

@bot.message_handler(commands=["sever"])
@increment_interaction_count
# L·ªánh /sever kh√¥ng c·∫ßn group_membership_required v√¨ ƒë√¢y l√† l·ªánh d√†nh ri√™ng cho Admin
def show_groups(message):
    logging.info(f"Received /sever from user {message.from_user.id} in chat {message.chat.id}")
    if message.from_user.id != ADMIN_ID:
        return send_message_robustly(message.chat.id, text="üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.", parse_mode="HTML", reply_to_message_id=message.message_id)
    
    with user_group_info_lock:
        if not GROUP_INFOS:
            return send_message_robustly(message.chat.id, text="üì≠ Hi·ªán t·∫°i bot ch∆∞a c√≥ th√¥ng tin v·ªÅ nh√≥m n√†o.", parse_mode="HTML", reply_to_message_id=message.message_id)
        
        text = "<b>üì¶ Sever:</b>\n\n"
        for g in GROUP_INFOS:
            title = g.get("title", "Kh√¥ng r√µ t√™n nh√≥m")
            link = f"https://t.me/{g.get('username')}" if g.get("username") else "‚õî Kh√¥ng c√≥ link m·ªùi"
            text += f"üìå <b>{title}</b>\n{link}\n\n"
    
    send_message_robustly(message.chat.id, text=text, parse_mode="HTML", disable_web_page_preview=True, reply_to_message_id=message.message_id)

@bot.message_handler(commands=['mail10p'])
@increment_interaction_count
@group_membership_required
def handle_mail10p(message):
    logging.info(f"Received /mail10p from user {message.from_user.id} in chat {message.chat.id}")
    sync_chat_to_server(message.chat)
    user_id = message.chat.id
    
    with user_data_lock:
        if user_id in user_data:
            elapsed_time = int(time.time() - user_data[user_id]["created_at"])
            remaining_time = 600 - elapsed_time
            if remaining_time > 0:
                minutes = remaining_time // 60
                seconds = remaining_time % 60
                
                mail_info_text = (
                    f"‚ö†Ô∏è B·∫°n ƒë√£ c√≥ m·ªôt mail 10 ph√∫t r·ªìi:\n"
                    f"üìß `{user_data[user_id]['email']}`\n"
                    f"‚è∞ Mail n√†y s·∫Ω h·∫øt h·∫°n sau {minutes} ph√∫t {seconds} gi√¢y."
                )
                markup = build_mail_buttons(user_id, 'mail_info')
                
                sent_msg = send_message_robustly(message.chat.id, 
                                                text=mail_info_text,
                                                parse_mode='Markdown',
                                                reply_markup=markup,
                                                reply_to_message_id=message.message_id)
                with mail_messages_state_lock:
                    if sent_msg:
                        bot.mail_messages_state[sent_msg.message_id] = {'chat_id': user_id, 'user_id': user_id, 'type': 'mail_info'}
                return
            else:
                del user_data[user_id]
                send_message_robustly(message.chat.id, "‚è∞ Mail 10 ph√∫t c·ªßa b·∫°n ƒë√£ h·∫øt h·∫°n, ƒëang t·∫°o mail m·ªõi...", parse_mode='Markdown', reply_to_message_id=message.message_id)

    email, pwd, token = create_temp_mail()

    if email:
        with user_data_lock:
            user_data[user_id] = {
                "email": email,
                "password": pwd,
                "token": token,
                "created_at": time.time()
            }
        
        mail_info_text = (
            f"‚úÖ Mail 10 ph√∫t c·ªßa b·∫°n l√†:\n"
            f"üìß `{email}`\n"
            f"‚è∞ H·∫øt h·∫°n sau 10 ph√∫t."
        )
        markup = build_mail_buttons(user_id, 'mail_info')
        
        sent_msg = send_message_robustly(message.chat.id, 
                                       text=mail_info_text, 
                                       parse_mode='Markdown',
                                       reply_markup=markup,
                                       reply_to_message_id=message.message_id)
        with mail_messages_state_lock:
            if sent_msg:
                bot.mail_messages_state[sent_msg.message_id] = {'chat_id': user_id, 'user_id': user_id, 'type': 'mail_info'}
        
        threading.Thread(target=auto_delete_email, args=(user_id,)).start()
    else:
        send_message_robustly(message.chat.id, "‚ùå Kh√¥ng th·ªÉ t·∫°o email. Vui l√≤ng th·ª≠ l·∫°i sau!", parse_mode='Markdown', reply_to_message_id=message.message_id)

@bot.message_handler(commands=['ping'])
@group_membership_required
def ping_command(message):
    start_time = time.time()
    
    sent_message = bot.send_message(message.chat.id, "ƒêang ƒêo Ping Sever Bot...", parse_mode='HTML')
    
    end_time = time.time()
    
    ping_ms = round((end_time - start_time) * 1000)

    html_message = f"""
<blockquote>
    <b>‚ö° Ping Sever Bot hi·ªán t·∫°i:</b> <i>{ping_ms}ms</i>
</blockquote>
"""
    keyboard = types.InlineKeyboardMarkup()
    refresh_button = types.InlineKeyboardButton("‚ôªÔ∏è L√†m m·ªõi Ping", callback_data='refresh_ping')
    keyboard.add(refresh_button)

    bot.edit_message_text(chat_id=message.chat.id, 
                          message_id=sent_message.message_id,
                          text=html_message, 
                          reply_markup=keyboard, 
                          parse_mode='HTML')

@bot.callback_query_handler(func=lambda call: call.data == 'refresh_ping')
def refresh_ping_callback(call):
    bot.answer_callback_query(call.id) 

    start_time = time.time()
    
    bot.edit_message_text(chat_id=call.message.chat.id, 
                          message_id=call.message.message_id,
                          text="ƒêang l√†m m·ªõi ping...", 
                          parse_mode='HTML')

    end_time = time.time()
    
    ping_ms = round((end_time - start_time) * 1000)

    html_message = f"""
<blockquote>
    <b>‚ö° Ping Sever Bot Hi·ªán T·∫°i hi·ªán t·∫°i:</b> <i>{ping_ms}ms</i>
</blockquote>
"""
    keyboard = types.InlineKeyboardMarkup()
    refresh_button = types.InlineKeyboardButton("‚ôªÔ∏è L√†m m·ªõi Ping", callback_data='refresh_ping')
    keyboard.add(refresh_button)

    bot.edit_message_text(chat_id=call.message.chat.id, 
                          message_id=call.message.message_id,
                          text=html_message, 
                          reply_markup=keyboard, 
                          parse_mode='HTML')

@bot.message_handler(commands=['xoamail10p'])
@increment_interaction_count
@group_membership_required
def handle_xoamail10p(message):
    logging.info(f"Received /xoamail10p from user {message.from_user.id} in chat {message.chat.id}")
    sync_chat_to_server(message.chat)
    user_id = message.chat.id

    with user_data_lock:
        if user_id in user_data:
            del user_data[user_id]
            send_message_robustly(message.chat.id, "<i>üóëÔ∏è Mail 10 ph√∫t c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c x√≥a th√†nh c√¥ng!</i>", parse_mode='HTML', reply_to_message_id=message.message_id)
        else:
            send_message_robustly(message.chat.id, "<i>‚ö†Ô∏è B·∫°n kh√¥ng c√≥ mail 10 ph√∫t n√†o ƒëang ho·∫°t ƒë·ªông ƒë·ªÉ x√≥a.<i>", parse_mode='HTML', reply_to_message_id=message.message_id)

def _get_inbox_content(user_id):
    with user_data_lock:
        info = user_data.get(user_id)

    if not info:
        return "<i>‚ùå B·∫°n ch∆∞a t·∫°o email. G√µ /mail10p ƒë·ªÉ t·∫°o nh√©!</i>", None, 'HTML'

    elapsed_time = int(time.time() - info["created_at"])
    if elapsed_time >= 600:
        expired_mail_address = info.get('email', 'kh√¥ng x√°c ƒë·ªãnh')

        with user_data_lock:
            del user_data[user_id]
        
        reply_text = (
            f"‚è∞ <b>Mail <code>{expired_mail_address}</code> c·ªßa b·∫°n ƒë√£ h·∫øt h·∫°n!</b> "
            f"<blockquote>T·∫•t c·∫£ th∆∞ c·ªßa mail n√†y s·∫Ω b·ªã x√≥a.</blockquote> "
            f"Vui l√≤ng t·∫°o mail m·ªõi b·∫±ng l·ªánh /mail10p."
        )
        return reply_text, None, 'HTML'

    headers = {
        "Authorization": f"Bearer {info['token']}"
    }

    try:
        r = session.get("https://api.mail.tm/messages", headers=headers)
        r.raise_for_status()
        messages = r.json().get("hydra:member", [])
        
        reply_text = ""
        if not messages:
            reply_text = "üì≠ H·ªôp th∆∞ c·ªßa b·∫°n hi·ªán ƒëang tr·ªëng."
        else:
            reply_text = f"üì• C√≥ {len(messages)} th∆∞ trong h·ªôp th∆∞:\n"
            for msg in messages:
                sender = msg['from']['address']
                subject = msg['subject']
                preview = msg['intro']
                
                sender_esc = html_escape(sender)
                subject_esc = html_escape(subject)
                preview_esc = html_escape(preview)

                reply_text += f"\nüë§ <b>T·ª´:</b> <code>{sender_esc}</code>\n" \
                              f"‚úâÔ∏è <b>Ch·ªß ƒë·ªÅ:</b> {subject_esc}\n" \
                              f"üìù <b>N·ªôi dung:</b> {preview_esc}\n"
        
        markup = build_mail_buttons(user_id, 'inbox')
        return reply_text, markup, 'HTML'

    except Exception as e:
        logging.error(f"L·ªói khi ki·ªÉm tra h·ªôp th∆∞ Mail.tm cho user {user_id}: {e}")
        return "‚ùå L·ªói khi ki·ªÉm tra h·ªôp th∆∞. Vui l√≤ng th·ª≠ l·∫°i sau.", None, 'Markdown'

@bot.message_handler(commands=['hopthu'])
@increment_interaction_count
@group_membership_required
def handle_hopthu(message):
    logging.info(f"Received /hopthu from user {message.from_user.id} in chat {message.chat.id}")
    sync_chat_to_server(message.chat)
    user_id = message.chat.id
    
    text, markup, parse_mode = _get_inbox_content(user_id)
    sent_msg = send_message_robustly(message.chat.id, 
                                   text=text, 
                                   parse_mode=parse_mode, 
                                   reply_markup=markup,
                                   reply_to_message_id=message.message_id)
    with mail_messages_state_lock:
        if sent_msg:
            bot.mail_messages_state[sent_msg.message_id] = {'chat_id': user_id, 'user_id': user_id, 'type': 'inbox'}

def format_ai_response_html(text):
    parts = []
    # Split by code blocks (```language\ncode\n``` or ```\ncode\n```)
    code_blocks = re.split(r"```(?:\w+)?\n(.*?)```", text, flags=re.DOTALL)

    for i, part in enumerate(code_blocks):
        if i % 2 == 0:  # This is a text part
            if part:
                parts.append({"type": "text", "content": html_escape(part.strip()), "raw_content": part.strip()})
        else:  # This is a code part
            if part:
                # Code blocks need special handling, but for HTML, <code> is fine.
                # MarkdownV2 would use backticks.
                formatted_code = f"<code>{html_escape(part.strip())}</code>"
                parts.append({"type": "code", "content": formatted_code, "raw_content": part.strip()})
    return parts

@bot.callback_query_handler(func=lambda call: call.data.startswith("copycode|"))
def copy_code_button(call):
    try:
        _, code_id = call.data.split("|", 1)
        with code_snippets_lock:
            code_content = bot.code_snippets.get(code_id)

        if code_content:
            bot.answer_callback_query(call.id, text="ƒê√£ sao ch√©p n·ªôi dung code!", show_alert=True)
            try:
                # Sending as MarkdownV2 to ensure correct code block formatting
                # Note: MarkdownV2 requires escaping specific characters
                # Simple escape for common MarkdownV2 special chars not in code
                escaped_code = code_content.replace("\\", "\\\\").replace("`", "\`").replace("*", "\*").replace("_", "\_").replace("~", "\~").replace(">", "\>").replace("#", "\#").replace("+", "\+").replace("-", "\-").replace("=", "\=").replace("|", "\|").replace("{", "\{").replace("}", "\}").replace(".", "\.").replace("!", "\!")
                
                bot.send_message(
                    chat_id=call.message.chat.id,
                    text=f"```\n{code_content}\n```", # Using original code content, let Telegram handle markdown
                    parse_mode="MarkdownV2",
                    reply_to_message_id=call.message.message_id
                )
            except telebot.apihelper.ApiTelegramException as e:
                logging.warning(f"Failed to send code snippet for copy to chat {call.message.chat.id} with MarkdownV2: {e}. Sending plain text.")
                bot.send_message(
                    chat_id=call.message.chat.id,
                    text=f"B·∫°n c√≥ th·ªÉ sao ch√©p ƒëo·∫°n code n√†y:\n\n{code_content}",
                    reply_to_message_id=call.message.message_id
                )
        else:
            bot.answer_callback_query(call.id, text="L·ªói: Kh√¥ng t√¨m th·∫•y n·ªôi dung code n√†y.", show_alert=True)
    except Exception as e:
        logging.error(f"L·ªói khi x·ª≠ l√Ω n√∫t copy code: {e}")
        bot.answer_callback_query(call.id, text="ƒê√£ x·∫£y ra l·ªói khi sao ch√©p code.", show_alert=True)

@bot.message_handler(commands=["ask"])
@increment_interaction_count
@group_membership_required
def ask_command(message):
    logging.info(f"Received /ask from user {message.from_user.id} in chat {message.chat.id}")
    sync_chat_to_server(message.chat)
    prompt = message.text.replace("/ask", "").strip()
    if not prompt:
        return send_message_robustly(message.chat.id, text="‚ùì B·∫°n ch∆∞a nh·∫≠p c√¢u h·ªèi r·ªìi ƒë√≥! Vui l√≤ng g√µ <code>/ask &lt;c√¢u h·ªèi c·ªßa b·∫°n&gt;</code>.", parse_mode="HTML", reply_to_message_id=message.message_id)

    try:
        msg_status = bot.send_message(message.chat.id, "ü§ñ", reply_to_message_id=message.message_id)
    except telebot.apihelper.ApiTelegramException as e:
        logging.warning(f"Failed to send initial 'thinking' message in chat {message.chat.id}: {e}. Proceeding without reply_to.")
        msg_status = bot.send_message(message.chat.id, "ü§ñ")

    user_id = message.from_user.id
    user_name = message.from_user.first_name
    memory = load_user_memory(user_id)

    try:
        prompt_data = session.get(REMOTE_PROMPT_URL, timeout=DEFAULT_TIMEOUT_GLOBAL).json()
        system_prompt = prompt_data.get("prompt", "B·∫°n l√† AI th√¥ng minh v√† h·ªØu √≠ch.")
    except Exception as e:
        logging.error(f"L·ªói t·∫£i prompt t·ª´ xa: {e}")
        system_prompt = "B·∫°n l√† AI th√¥ng minh v√† h·ªØu √≠ch."

    history_block = ""
    if memory:
        for item in memory[-5:]:
            history_block += f"Ng∆∞·ªùi d√πng h·ªèi: {item['question']}\nAI: {item['answer']}\n"

    full_prompt = f"{system_prompt}\n\n[Ng·ªØ c·∫£nh tr∆∞·ªõc ƒë√≥ v·ªõi {user_name}]\n{history_block}\nNg∆∞·ªùi d√πng hi·ªán t·∫°i h·ªèi: {prompt}"

    headers = {"Content-Type": "application/json"}
    parts = [{"text": full_prompt}]
    image_attached = False

    if message.reply_to_message and message.reply_to_message.photo:
        try:
            photo = message.reply_to_message.photo[-1]
            file_info = bot.get_file(photo.file_id)
            downloaded_file = bot.download_file(file_info.file_path)
            image = Image.open(BytesIO(downloaded_file))
            buffer = BytesIO()
            if image.mode in ("RGBA", "P"):
                image = image.convert("RGB")
            image.save(buffer, format="JPEG")
            base64_img = base64.b64encode(buffer.getvalue()).decode()
            parts.insert(0, {
                "inline_data": {
                    "mime_type": "image/jpeg",
                    "data": base64_img
                }
            })
            image_attached = True
        except Exception as e:
            logging.error(f"L·ªói x·ª≠ l√Ω ·∫£nh ƒë√≠nh k√®m: {e}")

    data = {"contents": [{"parts": parts}]}
    try:
        res = session.post(GEMINI_URL, headers=headers, json=data, timeout=DEFAULT_TIMEOUT_GLOBAL)
        res.raise_for_status()
        result = res.json()["candidates"][0]["content"]["parts"][0]["text"]
    except Exception as e:
        try:
            bot.edit_message_text(
                f"‚ùå ƒê√£ x·∫£y ra l·ªói khi g·ªçi API Gemini:\n<pre>{html_escape(str(e))}</pre>",
                msg_status.chat.id,
                msg_status.message_id,
                parse_mode="HTML"
            )
        except telebot.apihelper.ApiTelegramException as edit_e:
            logging.warning(f"Failed to edit message {msg_status.message_id}: {edit_e}. Sending new error message.")
            send_message_robustly(message.chat.id, text=f"‚ùå ƒê√£ x·∫£y ra l·ªói khi g·ªçi API Gemini:\n<pre>{html_escape(str(e))}</pre>", parse_mode="HTML")
        return

    entry = {
        "question": prompt,
        "answer": result,
        "created": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "with_image": image_attached,
        "name": message.from_user.first_name
    }
    memory.append(entry)
    save_user_memory(user_id, memory)

    try:
        session.post(
            f"{REMOTE_LOG_HOST}?uid={user_id}",
            data=json.dumps(memory, ensure_ascii=False),
            headers={"Content-Type": "application/json"},
            timeout=DEFAULT_TIMEOUT_GLOBAL
        )
    except Exception as e:
        logging.error(f"L·ªói g·ª≠i log t·ª´ xa: {e}")

    response_parts_structured = format_ai_response_html(result)
    reply_id = uuid.uuid4().hex[:6]
    
    with voice_map_lock:
        bot.voice_map[reply_id] = result

    total_raw_length = 0
    full_content_for_file = []
    for part in response_parts_structured:
        total_raw_length += len(part["raw_content"])
        if part["type"] == "text":
            full_content_for_file.append(part["raw_content"])
        elif part["type"] == "code":
            full_content_for_file.append(f"\n```\n{part['raw_content']}\n```\n")

    if total_raw_length > 1500 or any(p["type"] == "code" for p in response_parts_structured):
        filename = f"zproject_{reply_id}.txt"
        with open(filename, "w", encoding="utf-8") as f:
            f.write("".join(full_content_for_file))

        with open(filename, "rb") as f:
            try:
                bot.send_document(
                    message.chat.id,
                    f,
                    caption=f"üìÑ Tr·∫£ l·ªùi qu√° d√†i ho·∫∑c c√≥ code block! M√¨nh ƒë√£ ƒë√≥ng g√≥i v√†o file <code>{filename}</code> nha {html_escape(message.from_user.first_name)}!\n\n"
                            f"<i>Vui l√≤ng t·∫£i xu·ªëng ƒë·ªÉ xem to√†n b·ªô n·ªôi dung.</i>",
                    parse_mode="HTML",
                    reply_to_message_id=message.message_id
                )
            except telebot.apihelper.ApiTelegramException as e:
                logging.warning(f"Failed to send document replying to message {message.message_id}: {e}. Sending without reply_to.")
                f.seek(0)
                bot.send_document(
                    message.chat.id,
                    f,
                    caption=f"üìÑ Tr·∫£ l·ªùi qu√° d√†i ho·∫∑c c√≥ code block! M√¨nh ƒë√£ ƒë√≥ng g√≥i v√†o file <code>{filename}</code> nha {html_escape(message.from_user.first_name)}!\n\n"
                            f"<i>Vui l√≤ng t·∫£i xu·ªëng ƒë·ªÉ xem to√†n b·ªô n·ªôi dung.</i>",
                    parse_mode="HTML"
                )
        os.remove(filename)
        try:
            bot.delete_message(msg_status.chat.id, msg_status.message_id)
        except telebot.apihelper.ApiTelegramException as e:
            logging.warning(f"Failed to delete status message {msg_status.message_id}: {e}")

    else:
        main_markup = build_reply_button(user_id, prompt, reply_id)
        current_message_text = f"<blockquote expandable>ü§ñ <i>ZProject [WORMGPT] tr·∫£ l·ªùi:</i></blockquote>\n\n"
        
        combined_text_for_telegram = ""
        for part in response_parts_structured:
            if part["type"] == "text":
                combined_text_for_telegram += part["content"] + "\n\n"
            elif part["type"] == "code":
                copy_id = uuid.uuid4().hex[:8]
                with code_snippets_lock:
                    bot.code_snippets[copy_id] = part["raw_content"]
                
                code_markup = InlineKeyboardMarkup()
                code_markup.add(InlineKeyboardButton("üìÑ Sao ch√©p Code", callback_data=f"copycode|{copy_id}"))

                try:
                    if combined_text_for_telegram.strip():
                        bot.edit_message_text(
                            current_message_text + combined_text_for_telegram.strip(),
                            msg_status.chat.id,
                            msg_status.message_id,
                            parse_mode="HTML"
                        )
                        msg_status = None # Reset msg_status so we send a new message for code
                    
                    bot.send_message(
                        message.chat.id,
                        text=f"<b>Code:</b>\n{part['content']}",
                        parse_mode="HTML",
                        reply_markup=code_markup,
                        reply_to_message_id=message.message_id
                    )
                except telebot.apihelper.ApiTelegramException as e:
                    logging.warning(f"Failed to send code part in chat {message.chat.id}: {e}. Sending without reply_to.")
                    bot.send_message(
                        message.chat.id,
                        text=f"<b>Code:</b>\n{part['content']}",
                        parse_mode="HTML",
                        reply_markup=code_markup
                    )
                combined_text_for_telegram = "" # Clear buffer after sending code
        
        final_response_text = current_message_text + combined_text_for_telegram.strip()
        
        try:
            if msg_status: # If msg_status is still valid (meaning no code block was sent as a new message)
                bot.edit_message_text(
                    final_response_text,
                    msg_status.chat.id,
                    msg_status.message_id,
                    parse_mode="HTML",
                    reply_markup=main_markup
                )
            else: # If msg_status was consumed by a code block, send as a new message
                bot.send_message(
                    message.chat.id,
                    text=final_response_text,
                    parse_mode="HTML",
                    reply_markup=main_markup,
                    reply_to_message_id=message.message_id
                )
        except telebot.apihelper.ApiTelegramException as e:
            logging.warning(f"Failed to send/edit final message in chat {message.chat.id}: {e}. Sending as new message.")
            send_message_robustly(
                message.chat.id,
                text=final_response_text,
                parse_mode="HTML",
                reply_markup=main_markup,
                reply_to_message_id=message.message_id
            )
        except Exception as e:
            logging.error(f"Error in final message sending for /ask: {e}")
            send_message_robustly(message.chat.id, text=f"‚ùå ƒê√£ x·∫£y ra l·ªói khi g·ª≠i k·∫øt qu·∫£: {e}", parse_mode="HTML", reply_to_message_id=message.message_id)

# --- N√öT CALLBACK C·ª¶A BOT ZPROJECT ---

@bot.callback_query_handler(func=lambda call: call.data.startswith("retry|"))
def retry_button(call):
    try:
        _, uid, question = call.data.split("|", 2)
        if str(call.from_user.id) != uid:
            return bot.answer_callback_query(call.id, "üö´ B·∫°n kh√¥ng ph·∫£i ng∆∞·ªùi y√™u c·∫ßu c√¢u h·ªèi n√†y.", show_alert=True)

        # Ki·ªÉm tra t∆∞ c√°ch th√†nh vi√™n tr∆∞·ªõc khi th·ª±c hi·ªán retry
        if not check_group_membership(REQUIRED_GROUP_ID, call.from_user.id):
            markup = InlineKeyboardMarkup()
            markup.add(InlineKeyboardButton("Tham gia nh√≥m ngay", url=REQUIRED_GROUP_LINK))
            bot.answer_callback_query(call.id, "‚ö†Ô∏è Vui l√≤ng tham gia nh√≥m ƒë·ªÉ s·ª≠ d·ª•ng bot n√†y.", show_alert=True)
            bot.send_message(
                call.message.chat.id,
                text=f"‚ö†Ô∏è Vui l√≤ng tham gia nh√≥m <a href='{REQUIRED_GROUP_LINK}'>ZProject Th√¥ng B√°o</a> ƒë·ªÉ s·ª≠ d·ª•ng bot n√†y.",
                parse_mode="HTML",
                reply_markup=markup
            )
            return

        msg = SimpleNamespace(
            chat=call.message.chat,
            message_id=call.message.message_id,
            text="/ask " + question,
            from_user=call.from_user,
            reply_to_message=None # Ensure this is None for retries
        )

        bot.answer_callback_query(call.id, "üîÅ ƒêang th·ª≠ l·∫°i c√¢u h·ªèi...")
        try:
            bot.edit_message_text("ü§ñ ƒêang x·ª≠ l√Ω l·∫°i...", call.message.chat.id, call.message.message_id)
        except telebot.apihelper.ApiTelegramException as e:
            logging.warning(f"Failed to edit message {call.message.message_id} on retry: {e}. Sending new 'thinking' message.")
            bot.send_message(call.message.chat.id, "ü§ñ ƒêang x·ª≠ l√Ω l·∫°i...", reply_to_message_id=call.message.message_id)

        Thread(target=ask_command, args=(msg,)).start()

    except Exception as e:
        bot.answer_callback_query(call.id, "‚ö†Ô∏è L·ªói khi th·ª≠ l·∫°i!", show_alert=True)
        logging.error(f"[RETRY] L·ªói: {e}")

@bot.callback_query_handler(func=lambda call: call.data.startswith("tts|"))
def tts_button(call):
    try:
        parts = call.data.split("|")
        uid = parts[1]
        reply_id = parts[2]

        if str(call.from_user.id) != uid:
            return bot.answer_callback_query(call.id, "üö´ B·∫°n kh√¥ng ph·∫£i ng∆∞·ªùi y√™u c·∫ßu voice n√†y.", show_alert=True)

        # Ki·ªÉm tra t∆∞ c√°ch th√†nh vi√™n tr∆∞·ªõc khi t·∫°o TTS
        if not check_group_membership(REQUIRED_GROUP_ID, call.from_user.id):
            markup = InlineKeyboardMarkup()
            markup.add(InlineKeyboardButton("Tham gia nh√≥m ngay", url=REQUIRED_GROUP_LINK))
            bot.answer_callback_query(call.id, "‚ö†Ô∏è Vui l√≤ng tham gia nh√≥m ƒë·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y.", show_alert=True)
            bot.send_message(
                call.message.chat.id,
                text=f"‚ö†Ô∏è Vui l√≤ng tham gia nh√≥m <a href='{REQUIRED_GROUP_LINK}'>ZProject Th√¥ng B√°o</a> ƒë·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y.",
                parse_mode="HTML",
                reply_markup=markup
            )
            return

        with voice_map_lock:
            answer = bot.voice_map.get(reply_id)
        if not answer:
            return bot.answer_callback_query(call.id, "‚ùå Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu gi·ªçng n√≥i.", show_alert=True)

        clean_text = re.sub(r"<code>.*?</code>", "", answer, flags=re.DOTALL)
        clean_text = re.sub(r"<[^>]+>", "", clean_text)
        clean_text = re.sub(r"```.*?```", "", clean_text, flags=re.DOTALL)
        clean_text = clean_text.replace('"', '').replace("'", '')

        text_to_speak = clean_text.strip()

        if not text_to_speak or len(text_to_speak) < 5:
            return bot.answer_callback_query(call.id, "‚ùó N·ªôi dung qu√° ng·∫Øn ho·∫∑c r·ªóng ƒë·ªÉ chuy·ªÉn voice.", show_alert=True)

        filename = f"zproject_tts_{reply_id}.mp3"
        tts = gTTS(text=text_to_speak, lang="vi", slow=False)
        tts.save(filename)

        with open(filename, "rb") as f:
            try:
                bot.send_voice(call.message.chat.id, f, caption="üó£Ô∏è ƒê√¢y l√† Voice ZProject:v", reply_to_message_id=call.message.message_id)
            except telebot.apihelper.ApiTelegramException as e:
                logging.warning(f"Failed to send voice replying to message {call.message.message_id}: {e}. Sending without reply_to.")
                f.seek(0)
                bot.send_voice(call.message.chat.id, f, caption="üó£Ô∏è ƒê√¢y l√† Voice ZProject:v")
        os.remove(filename)
        bot.answer_callback_query(call.id, "üéß Voice ƒë√£ ƒë∆∞·ª£c g·ª≠i!")
    except Exception as e:
        bot.answer_callback_query(call.id, "‚ö†Ô∏è L·ªói khi t·∫°o voice.", show_alert=True)
        logging.error(f"[TTS] L·ªói: {e}")

# --- N√öT CALLBACK C·ª¶A MAIL.TM ---

def check_mail_owner(call, expected_user_id):
    if call.from_user.id != int(expected_user_id):
        markup = InlineKeyboardMarkup()
        markup.add(InlineKeyboardButton("Tham gia nh√≥m ngay", url=REQUIRED_GROUP_LINK))
        bot.answer_callback_query(call.id, "üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y. Vui l√≤ng tham gia nh√≥m.", show_alert=True)
        bot.send_message(
            call.message.chat.id,
            text=f"‚ö†Ô∏è Vui l√≤ng tham gia nh√≥m <a href='{REQUIRED_GROUP_LINK}'>ZProject Th√¥ng B√°o</a> ƒë·ªÉ s·ª≠ d·ª•ng bot n√†y.",
            parse_mode="HTML",
            reply_markup=markup
        )
        return False
    return True

@bot.callback_query_handler(func=lambda call: call.data.startswith("mailtm_inbox|"))
def show_inbox_button(call):
    user_id = call.message.chat.id
    expected_user_id = call.data.split("|")[1]

    if not check_mail_owner(call, expected_user_id):
        return

    bot.answer_callback_query(call.id, "ƒêang t·∫£i h·ªôp th∆∞...", show_alert=False)

    text, markup, parse_mode = _get_inbox_content(user_id)

    try:
        bot.edit_message_text(
            chat_id=call.message.chat.id,
            message_id=call.message.message_id,
            text=text,
            parse_mode=parse_mode,
            reply_markup=markup
        )
        with mail_messages_state_lock:
            if call.message.message_id in bot.mail_messages_state:
                bot.mail_messages_state[call.message.message_id]['type'] = 'inbox'
    except telebot.apihelper.ApiTelegramException as e:
        if "message is not modified" in str(e):
            logging.info(f"Message {call.message.message_id} in chat {call.message.chat.id} was not modified (inbox).")
        else:
            logging.error(f"L·ªói khi ch·ªânh s·ª≠a tin nh·∫Øn th√†nh h·ªôp th∆∞ cho user {user_id}: {e}")
            # Fallback to sending a new message if edit fails
            send_message_robustly(call.message.chat.id, text=text, parse_mode=parse_mode, reply_markup=markup)
            with mail_messages_state_lock:
                if call.message.message_id in bot.mail_messages_state:
                    del bot.mail_messages_state[call.message.message_id] # Clean up old state
                sent_msg = send_message_robustly(call.message.chat.id, "‚ùå ƒê√£ c√≥ l·ªói khi c·∫≠p nh·∫≠t h·ªôp th∆∞. ƒê√¢y l√† tin nh·∫Øn m·ªõi.", parse_mode="HTML")
                if sent_msg:
                    bot.mail_messages_state[sent_msg.message_id] = {'chat_id': user_id, 'user_id': user_id, 'type': 'inbox'}
            
    except Exception as e:
        logging.error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh khi xem h·ªôp th∆∞: {e}")
        bot.answer_callback_query(call.id, "‚ö†Ô∏è L·ªói khi xem h·ªôp th∆∞!", show_alert=True)

@bot.callback_query_handler(func=lambda call: call.data.startswith("mailtm_refresh|"))
def refresh_inbox_button(call):
    user_id = call.message.chat.id
    expected_user_id = call.data.split("|")[1]

    if not check_mail_owner(call, expected_user_id):
        return

    bot.answer_callback_query(call.id, "ƒêang l√†m m·ªõi h·ªôp th∆∞...", show_alert=False)

    text, markup, parse_mode = _get_inbox_content(user_id)

    try:
        bot.edit_message_text(
            chat_id=call.message.chat.id,
            message_id=call.message.message_id,
            text=text,
            parse_mode=parse_mode,
            reply_markup=markup
        )
        with mail_messages_state_lock:
            if call.message.message_id in bot.mail_messages_state:
                bot.mail_messages_state[call.message.message_id]['type'] = 'inbox'
    except telebot.apihelper.ApiTelegramException as e:
        if "message is not modified" in str(e):
            logging.info(f"Message {call.message.message_id} in chat {call.message.chat.id} was not modified (refresh inbox).")
        else:
            logging.error(f"L·ªói khi l√†m m·ªõi h·ªôp th∆∞ cho user {user_id}: {e}")
            # Fallback to sending a new message if edit fails
            send_message_robustly(call.message.chat.id, text=text, parse_mode=parse_mode, reply_markup=markup)
            with mail_messages_state_lock:
                if call.message.message_id in bot.mail_messages_state:
                    del bot.mail_messages_state[call.message.message_id]
                sent_msg = send_message_robustly(call.message.chat.id, "‚ùå ƒê√£ c√≥ l·ªói khi l√†m m·ªõi h·ªôp th∆∞. ƒê√¢y l√† tin nh·∫Øn m·ªõi.", parse_mode="HTML")
                if sent_msg:
                    bot.mail_messages_state[sent_msg.message_id] = {'chat_id': user_id, 'user_id': user_id, 'type': 'inbox'}
    except Exception as e:
        logging.error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh khi l√†m m·ªõi h·ªôp th∆∞: {e}")
        bot.answer_callback_query(call.id, "‚ö†Ô∏è L·ªói khi l√†m m·ªõi h·ªôp th∆∞!", show_alert=True)

@bot.callback_query_handler(func=lambda call: call.data.startswith("mailtm_back|"))
def back_to_mail_info_button(call):
    user_id = call.message.chat.id
    expected_user_id = call.data.split("|")[1]

    if not check_mail_owner(call, expected_user_id):
        return
    
    bot.answer_callback_query(call.id, "Quay l·∫°i th√¥ng tin mail...", show_alert=False)

    with user_data_lock:
        info = user_data.get(user_id)

    if not info:
        text = "<i>‚ùå B·∫°n ch∆∞a t·∫°o email. G√µ /mail10p ƒë·ªÉ t·∫°o nh√©!</i>"
        markup = None
        parse_mode = 'HTML'
    else:
        elapsed_time = int(time.time() - info["created_at"])
        remaining_time = 600 - elapsed_time
        if remaining_time > 0:
            minutes = remaining_time // 60
            seconds = remaining_time % 60
            text = (
                f"<blockquote>‚úÖ Mail 10 ph√∫t c·ªßa b·∫°n l√†:\n"
                f"<code>üìß {info['email']}</code>\n"
                f"‚è∞ H·∫øt h·∫°n sau {minutes} ph√∫t {seconds} gi√¢y.</blockquote>"
            )
            markup = build_mail_buttons(user_id, 'mail_info')
            parse_mode = 'HTML'
        else:
            with user_data_lock:
                del user_data[user_id]
            text = "‚è∞ Mail 10 ph√∫t c·ªßa b·∫°n ƒë√£ h·∫øt h·∫°n! Vui l√≤ng t·∫°o mail m·ªõi b·∫±ng l·ªánh /mail10p."
            markup = None
            parse_mode = 'HTML'
    
    try:
        bot.edit_message_text(
            chat_id=call.message.chat.id,
            message_id=call.message.message_id,
            text=text,
            parse_mode=parse_mode,
            reply_markup=markup
        )
        with mail_messages_state_lock:
            if call.message.message_id in bot.mail_messages_state:
                bot.mail_messages_state[call.message.message_id]['type'] = 'mail_info'
    except telebot.apihelper.ApiTelegramException as e:
        if "message is not modified" in str(e):
            logging.info(f"Message {call.message.message_id} in chat {call.message.chat.id} was not modified (back to mail info).")
        else:
            logging.error(f"L·ªói khi ch·ªânh s·ª≠a tin nh·∫Øn v·ªÅ th√¥ng tin mail cho user {user_id}: {e}")
            # Fallback to sending a new message if edit fails
            send_message_robustly(call.message.chat.id, text=text, parse_mode=parse_mode, reply_markup=markup)
            with mail_messages_state_lock:
                if call.message.message_id in bot.mail_messages_state:
                    del bot.mail_messages_state[call.message.message_id]
                sent_msg = send_message_robustly(call.message.chat.id, "‚ùå ƒê√£ c√≥ l·ªói khi quay l·∫°i th√¥ng tin mail. ƒê√¢y l√† tin nh·∫Øn m·ªõi.", parse_mode="HTML")
                if sent_msg:
                    bot.mail_messages_state[sent_msg.message_id] = {'chat_id': user_id, 'user_id': user_id, 'type': 'mail_info'}
    except Exception as e:
        logging.error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh khi quay l·∫°i th√¥ng tin mail: {e}")
        bot.answer_callback_query(call.id, "‚ö†Ô∏è L·ªói khi quay l·∫°i th√¥ng tin mail!", show_alert=True)

pressed_info_buttons = set()

@bot.message_handler(content_types=['new_chat_members'])
def duongcongbangdev_welcome(message):
    for member in message.new_chat_members:
        markup = InlineKeyboardMarkup()
        markup.add(
            InlineKeyboardButton("üßë‚Äçüíª Admin", url="t.me/zproject2"),
            InlineKeyboardButton("üì¢ Group Th√¥ng B√°o", url=REQUIRED_GROUP_LINK)
        )
        markup.add(
            InlineKeyboardButton("üí¨ Group Chat Ch√≠nh", url="https://t.me/zproject4"),
            InlineKeyboardButton("‚ÑπÔ∏è Th√¥ng Tin C·ªßa B·∫°n", callback_data=f"user_info_{member.id}")
        )
        
        video = random.choice(["https://i.pinimg.com/originals/ff/81/de/ff81dee1dcdd40d560569fe2ae94b6d3.gif"])
        
        welcome = (
            f"<blockquote><code>‚ùñ üéâ ZprojectX Bot Welcome üéâ ‚ùñ</code></blockquote>\n\n"
            f"<blockquote><i>‚ú° Xin Ch√†o üëã!</i> <a href='tg://user?id={member.id}'>{member.first_name}</a></blockquote>\n"
            f"<blockquote><b>‚û© ƒê√£ Tham Gia Nh√≥m: <b>{message.chat.title}</b></b></blockquote>\n"
            f"<blockquote><i>‚û© S·ªë th√†nh vi√™n hi·ªán t·∫°i: {bot.get_chat_members_count(message.chat.id)}</i></blockquote>\n"
            "<blockquote><i>‚ñ£ D√πng /help ƒë·ªÉ xem all l·ªánh c·ªßa bot</i></blockquote>\n"
            "<blockquote><code>‚ñ£ D√πng /phanhoi n·ªôi dung | ƒê·ªÉ G·ª≠i Ph·∫£n H·ªìi L·ªói Ho·∫∑c Ch·ª©c NƒÉng C·∫ßn C·∫£i Ti·∫øn!</code></blockquote>\n"
        )
        
        bot.send_video(
            message.chat.id,
            video=video,
            caption=welcome,
            reply_to_message_id=message.message_id,
            supports_streaming=True,
            parse_mode='HTML',
            reply_markup=markup
        )

@bot.callback_query_handler(func=lambda call: True)
def duongcongbangdev_handle_callback(call):
    if call.data.startswith("user_info_"):
        user_id = int(call.data.split("_")[2])
        message_id = call.message.message_id

        if (message_id, user_id) in pressed_info_buttons:
            bot.answer_callback_query(call.id, "B·∫°n ƒê√£ Xem R·ªìi C√≤n C√≥ √ù ƒê·ªãnh Spam Th√¨ Tu·ªïi Nh√©!", show_alert=True)
            return

        pressed_info_buttons.add((message_id, user_id))

        try:
            member_info = bot.get_chat_member(call.message.chat.id, user_id)
            user = member_info.user
            
            user_info_message = (
                f"<i>‚ú® Th√¥ng Tin Th√†nh Vi√™n ‚ú®</i>\n\n"
                f"üë§ T√™n: {user.first_name} {user.last_name if user.last_name else ''}\n"
                f"üÜî ID: `{user.id}`\n"
                f"üëã Username: @{user.username}\n" if user.username else f"üëã Username: Kh√¥ng c√≥\n"
                f"üîó Link Profile: [Xem Profile](tg://user?id={user.id})\n"
                f"üåü L√† Bot: {'C√≥' if user.is_bot else 'Kh√¥ng'}\n"
                f"üìà Tr·∫°ng Th√°i Trong Nh√≥m: {member_info.status.capitalize()}\n"
                f"üóìÔ∏è Th·ªùi Gian Tham Gia: {member_info.until_date if member_info.until_date else 'Kh√¥ng x√°c ƒë·ªãnh'}\n"
            )
            bot.send_message(call.message.chat.id, user_info_message, parse_mode='HTML')
            bot.answer_callback_query(call.id, "Th√¥ng tin ƒë√£ ƒë∆∞·ª£c g·ª≠i!")
            
        except Exception as e:
            bot.answer_callback_query(call.id, f"Kh√¥ng th·ªÉ l·∫•y th√¥ng tin: {e}", show_alert=True)

# === Webhook Flask ===
@app.route("/")
def index():
    return "<h3>üõ∞Ô∏è ZProject Bot ƒëang ho·∫°t ƒë·ªông!</h3>"

@app.route(f"/{TOKEN}", methods=["POST"])
def webhook():
    try:
        update = telebot.types.Update.de_json(request.data.decode("utf-8"))
        bot.process_new_updates([update])
        return "OK", 200
    except Exception as e:
        logging.error(f"L·ªói webhook: {e}")
        return "Error", 500

if __name__ == "__main__":
    try:
        webhook_info = bot.get_webhook_info()
        current_webhook_url = f"{APP_URL}/{TOKEN}"
        if webhook_info.url != current_webhook_url:
            logging.info(f"Webhook hi·ªán t·∫°i ({webhook_info.url}) kh√¥ng kh·ªõp v·ªõi URL mong mu·ªën ({current_webhook_url}). ƒêang x√≥a v√† ƒë·∫∑t l·∫°i webhook.")
            bot.remove_webhook()
            time.sleep(1)
            bot.set_webhook(url=current_webhook_url)
            logging.info(f"Webhook ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t t·ªõi: {current_webhook_url}")
        else:
            logging.info(f"Webhook ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t ch√≠nh x√°c t·ªõi: {current_webhook_url}")

        # --- Th√™m lu·ªìng auto-like t·∫°i ƒë√¢y ---
        threading.Thread(target=auto_like_scheduler, daemon=True).start()
        # -----------------------------------

        port = int(os.environ.get("PORT", 10000))
        app.run(host="0.0.0.0", port=port)
    except Exception as e:
        logging.critical(f"L·ªói nghi√™m tr·ªçng khi kh·ªüi ƒë·ªông bot: {e}")
